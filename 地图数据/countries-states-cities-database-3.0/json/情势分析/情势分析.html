<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∏ñÁïåÊÉÖÂäøÊ†áÊ≥®Á≥ªÁªü</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            overflow: hidden;
        }

        #map {
            width: 100vw;
            height: 100vh;
            cursor: default;
        }

        #map.pan-mode { cursor: grab; }
        #map.pan-mode:active { cursor: grabbing; }
        #map.eraser-mode { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><text y="20" font-size="20">üßπ</text></svg>') 12 12, auto; }

        #zoom-control {
            position: fixed;
            left: 16.08px;
            top: 50%;
            transform: translateY(-50%) scale(0.804);
            transform-origin: left center;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            padding: 20px 15px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        #zoom-slider-container {
            position: relative;
            height: 300px;
            width: 6px;
            background: rgba(200, 200, 200, 0.5);
            border-radius: 3px;
        }

        #zoom-slider-track {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #666666;
            border-radius: 3px;
            transition: height 0.2s;
        }

        #zoom-slider-thumb {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 18px;
            height: 18px;
            background: white;
            border: 2px solid #666666;
            border-radius: 50%;
            cursor: grab;
            transition: bottom 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        #zoom-slider-thumb:active {
            cursor: grabbing;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        #zoom-levels {
            display: flex;
            flex-direction: column-reverse;
            justify-content: space-between;
            height: 300px;
            user-select: none;
            position: relative;
        }

        .zoom-level-mark {
            height: 2px;
            display: flex;
            align-items: center;
            position: relative;
        }

        .zoom-level-mark::before {
            content: '';
            position: absolute;
            left: 0;
            width: 8px;
            height: 2px;
            background: #999;
            border-radius: 1px;
        }

        .zoom-level-mark.current::before {
            background: #666666;
            width: 12px;
            height: 3px;
        }

        #date-selector {
            position: fixed;
            top: 16.08px;
            left: 50%;
            transform: translateX(-50%) scale(0.804);
            transform-origin: top center;
            background: rgba(255, 255, 255, 0.5); 
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 320px;
        }

        #date-display {
            font-size: 18px;
            font-weight: bold;
            color: #666; 
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background 0.2s;
        }

        #date-display:hover {
            background: rgba(102, 102, 102, 0.1); 
        }

        #calendar-container {
            display: none;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            width: 280px;
        }

        #calendar-container.show {
            display: block;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .calendar-header button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .calendar-header button:hover {
            opacity: 0.9;
        }

        .calendar-header select {
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }

        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin-bottom: 5px;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
        }

        .calendar-day-header {
            text-align: center;
            font-weight: bold;
            font-size: 12px;
            padding: 5px;
            color: #666;
        }

        .calendar-day {
            text-align: center;
            padding: 8px 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
        }

        .calendar-day:hover {
            background: #e3f2fd;
        }

        .calendar-day.other-month {
            color: #ccc;
        }

        .calendar-day.selected {
            background: #4CAF50;
            color: white;
        }

        .calendar-day.today {
            border: 2px solid #2196F3;
        }

        .btn {
            padding: 8px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn:hover {
            background: #45a049;
        }

        #tool-panel {
            position: fixed;
            bottom: 16.08px;
            left: 50%;
            transform: translateX(-50%) scale(0.804);
            transform-origin: bottom center;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            transition: all 0.3s;
            padding: 0;
            overflow: visible;
        }

        #tool-icons {
            display: flex;
            padding: 7px 14px;
            align-items: center;
            position: relative;
            justify-content: space-evenly;
            min-width: 350px; 
        }

        .tool-icon {
            font-size: 19px;
            cursor: pointer;
            padding: 5px;
            border-radius: 8px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-icon:hover:not(.active) {
            background: rgba(255, 255, 255, 0.8);
        }

        .tool-icon::before {
            display: none;
        }

        .tool-icon::after {
            content: attr(data-tooltip);
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 10000;
        }

        .tool-icon:hover:not(.active)::after {
            opacity: 1;
        }

        .tool-options-popup {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            visibility: hidden;
            opacity: 0;
            min-width: 250px;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 1000;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 7px;
            padding: 0;
        }

        .tool-options-popup.show {
            visibility: visible;
            opacity: 1;
            padding: 10px 14px;
        }

        .tool-separator {
            width: 2px;
            height: 20px;
            background: rgba(68, 68, 68, 0.5);
        }

        .help-icon {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 18px;
            height: 18px;
            background: #999;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            z-index: 10;
            grid-column: auto;
        }

        .help-icon::after {
            content: attr(data-hint);
            position: absolute;
            bottom: calc(100% + 8px);
            right: 0;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            font-weight: normal;
        }

        .help-icon:hover::after {
            opacity: 1;
        }
        
        .option-group label {
            font-size: 10px;
            margin-bottom: 3px;
        }

        .option-group select,
        .option-group input[type="number"],
        .option-group input[type="text"],
        .option-group input[type="range"] {
            width: 100%;
            padding: 3px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 10px;
        }

        .color-picker {
            display: flex;
            align-items: center;
        }

        .color-picker input[type="color"] {
            width: 30px;
            height: 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #hint {
            position: fixed;
            bottom: 64.32px;
            left: 50%;
            transform: translateX(-50%) scale(0.804);
            transform-origin: bottom center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 7px 14px;
            border-radius: 5px;
            display: none;
            z-index: 998;
        }

        #text-to-marker-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.804);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 2000;
            min-width: 500px;
            max-width: 700px;
            display: none;
        }

        #text-to-marker-panel.show {
            display: block;
        }

        .text-to-marker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .text-to-marker-header h3 {
            margin: 0;
            color: #333;
        }

        .close-text-to-marker {
            cursor: pointer;
            font-size: 20px;
            color: #999;
        }

        #text-to-marker-input {
            width: 100%;
            min-height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 13px;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            resize: vertical;
        }

        .text-to-marker-example {
            margin: 10px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            font-size: 12px;
            color: #666;
        }

        .text-to-marker-options {
            margin: 15px 0;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .text-to-marker-options label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
        }

        .text-to-marker-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .text-to-marker-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .text-to-marker-buttons .btn-parse {
            background: #4CAF50;
            color: white;
        }

        .text-to-marker-buttons .btn-parse:hover {
            background: #45a049;
        }

        .text-to-marker-buttons .btn-cancel {
            background: #f44336;
            color: white;
        }

        .text-to-marker-buttons .btn-cancel:hover {
            background: #d32f2f;
        }

        #layers-panel {
            position: fixed;
            left: 16.08px;
            top: 16.08px;
            width: 280px;
            max-height: calc(100vh - 400px);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: scale(0.804);
            transform-origin: top left;
        }

        .layers-header {
            padding: 12px 15px;
            background: rgba(102, 102, 102, 0.1);
            border-bottom: 1px solid rgba(0,0,0,0.1);
            font-weight: bold;
            font-size: 14px;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layers-content {
            overflow-y: auto;
            flex: 1;
            padding: 10px;
        }

        .layer-section {
            margin-bottom: 15px;
        }

        .layer-section-title {
            font-size: 12px;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
            padding: 5px 8px;
            background: rgba(0,0,0,0.05);
            border-radius: 4px;
        }

        .layer-item {
            padding: 8px 10px;
            margin-bottom: 5px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .layer-item:hover {
            background: #f5f5f5;
            border-color: #4CAF50;
        }

        .layer-item-info {
            flex: 1;
            overflow: hidden;
        }

        .layer-item-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-item-date {
            color: #999;
            font-size: 10px;
        }

        .layer-item-actions {
            display: flex;
            gap: 5px;
        }

        .layer-action-btn {
            padding: 3px 8px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: background 0.2s;
        }

        .layer-action-btn:hover {
            background: #d32f2f;
        }

        .layer-action-btn.toggle {
            background: #4CAF50;
        }

        .layer-action-btn.toggle.hidden {
            background: #999;
        }

        .geojson-upload {
            margin-bottom: 10px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 5px;
        }

        .geojson-upload label {
            display: block;
            font-size: 11px;
            color: #333;
            margin-bottom: 5px;
        }

        .geojson-upload input[type="file"] {
            display: none;
        }

        .geojson-upload button {
            width: 100%;
            padding: 8px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .geojson-upload button:hover {
            background: #1976D2;
        }
        
        .custom-marker {
            text-align: center;
            line-height: 1;
        }
        .pin-icon svg, .pushpin-icon svg {
            width: 24px;
            height: 24px;
            display: block;
            margin: auto;
        }
        .dot-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            background: red;
            margin: auto;
            transform: translateY(-50%);
        }

        .text-box {
            position: absolute;
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #4CAF50;
            min-width: 200px;
            min-height: 100px;
            cursor: move;
            z-index: 500;
        }

        .text-box textarea {
            width: 100%;
            height: 80px;
            border: none;
            resize: none;
            background: transparent;
        }

        .text-box-close {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            color: #f44336;
            font-weight: bold;
        }

        #location-panel {
            position: fixed;
            bottom: 64.32px;
            left: 50%;
            transform: translateX(-50%) scale(0.804);
            transform-origin: bottom center;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 999;
            min-width: 400px;
            max-width: 500px;
            display: none;
        }

        .location-select-group {
            margin-bottom: 15px;
        }

        .location-select-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            font-weight: bold;
            color: #333;
        }

        .location-select-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .location-select-group select:disabled {
            background: #f5f5f5;
            cursor: not-allowed;
            color: #999;
        }

        .result-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s;
        }

        .result-item:hover {
            background: #e3f2fd;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        #file-controls {
            position: fixed;
            top: 16.08px;
            right: 16.08px;
            z-index: 1000;
            display: flex;
            gap: 10px;
            transform: scale(0.804);
            transform-origin: top right;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 7px 14px; 
            align-items: center;
        }

        .file-icon {
            font-size: 19px;
            cursor: pointer;
            padding: 5px;
            border-radius: 8px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 1;
            display: flex; 
            align-items: center;
            justify-content: center;
        }

        .file-icon:hover {
            background: rgba(255, 255, 255, 0.8);
        }
        
        .file-icon::after {
            content: attr(data-tooltip);
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 10000;
        }

        .file-icon:hover::after {
            opacity: 1;
        }

        #settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.804);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 2000;
            min-width: 300px;
            display: none;
        }

        #settings-panel.show {
            display: block;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .settings-header h3 {
            margin: 0;
            color: #333;
        }

        .close-settings {
            cursor: pointer;
            font-size: 20px;
            color: #999;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #666;
        }

        .setting-item input[type="color"] {
            width: 100%;
            height: 40px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
        }

        .setting-item input[type="range"] {
            width: 100%;
        }

        .opacity-value {
            color: #2196F3;
            font-weight: bold;
        }

        .boundary-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        .boundary-controls label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #333;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
            font-size: 12px;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="hint"></div>

    <!-- Â∑¶‰æßÂõæÂ±ÇÈù¢Êùø -->
    <div id="layers-panel">
        <div class="layers-header">
            <span>ÂõæÂ±ÇÁÆ°ÁêÜ</span>
            <span style="cursor: pointer; font-size: 16px;" id="toggle-layers">‚ñº</span>
        </div>
        <div class="layers-content">
            <!-- ËæπÁïåÂõæÂ±Ç -->
            <div class="layer-section">
                <div class="layer-section-title">ËæπÁïåÂõæÂ±Ç (<span id="boundary-count">0</span>)</div>
                <div id="boundary-layers-list"></div>
            </div>

            <!-- ‰∫ã‰ª∂ÂõæÂ±Ç -->
            <div class="layer-section">
                <div class="layer-section-title">‰∫ã‰ª∂ (<span id="event-count">0</span>)</div>
                <div id="event-layers-list"></div>
            </div>

            <!-- Ê†áËÆ∞ÂõæÂ±Ç -->
            <div class="layer-section">
                <div class="layer-section-title">Ê†áËÆ∞ (<span id="marker-count">0</span>)</div>
                <div id="marker-layers-list"></div>
            </div>

            <!-- Á∫øÊù°ÂõæÂ±Ç -->
            <div class="layer-section">
                <div class="layer-section-title">Á∫øÊù°/ÁÆ≠Â§¥ (<span id="line-count">0</span>)</div>
                <div id="line-layers-list"></div>
            </div>

            <!-- ÊñáÊú¨ÂõæÂ±Ç -->
            <div class="layer-section">
                <div class="layer-section-title">ÊñáÊú¨Ê°Ü (<span id="text-count">0</span>)</div>
                <div id="text-layers-list"></div>
            </div>
        </div>
    </div>

    <div id="zoom-control">
        <div id="zoom-slider-container">
            <div id="zoom-slider-track"></div>
            <div id="zoom-slider-thumb"></div>
        </div>
        <div id="zoom-levels"></div>
    </div>

    <div id="date-selector">
        <div id="date-display">ÂΩìÂâçÊó•Êúü: 2025-01-01</div>
        <div id="calendar-container">
            <div class="calendar-header">
                <button id="prev-month">‚óÄ</button>
                <div>
                    <select id="year-select"></select>
                    <select id="month-select">
                        <option value="0">1Êúà</option>
                        <option value="1">2Êúà</option>
                        <option value="2">3Êúà</option>
                        <option value="3">4Êúà</option>
                        <option value="4">5Êúà</option>
                        <option value="5">6Êúà</option>
                        <option value="6">7Êúà</option>
                        <option value="7">8Êúà</option>
                        <option value="8">9Êúà</option>
                        <option value="9">10Êúà</option>
                        <option value="10">11Êúà</option>
                        <option value="11">12Êúà</option>
                    </select>
                </div>
                <button id="next-month">‚ñ∂</button>
            </div>
            <div class="calendar-weekdays">
                <div class="calendar-day-header">Êó•</div>
                <div class="calendar-day-header">‰∏Ä</div>
                <div class="calendar-day-header">‰∫å</div>
                <div class="calendar-day-header">‰∏â</div>
                <div class="calendar-day-header">Âõõ</div>
                <div class="calendar-day-header">‰∫î</div>
                <div class="calendar-day-header">ÂÖ≠</div>
            </div>
            <div class="calendar-grid" id="calendar-days"></div>
        </div>
    </div>

    <div id="tool-panel">
        <div id="tool-icons">
            <div class="tool-icon active" data-tool="pan" data-tooltip="Âπ≥ÁßªÂú∞Âõæ">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 11l3-3m0 0l3 3m-3-3v8m0-13a9 9 0 110 18 9 9 0 010-18z"/>
                </svg>
            </div>
            <div class="tool-separator"></div>
            
            <div class="tool-icon" data-tool="annotate" data-tooltip="Ê∑ªÂä†Ê†áËÆ∞/ÁªòÂà∂Á∫øÊù°">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                </svg>
            </div>

            <div class="tool-icon" data-tool="text" data-tooltip="Ê∑ªÂä†ÊñáÊú¨">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 7V4h16v3M9 20h6M12 4v16"/>
                </svg>
            </div>
            <div class="tool-separator"></div>
            <div class="tool-icon" data-tool="location" data-tooltip="‰ΩçÁΩÆÊêúÁ¥¢">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/><path d="M2 12h20M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"/>
                </svg>
            </div>
            <div class="tool-separator"></div>
            <div class="tool-icon" data-tool="eraser" data-tooltip="Êì¶Èô§Ê†áÊ≥®">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 4l6 6-8 8-6-6 8-8zM5 16l-3 3h10"/>
                </svg>
            </div>
            <div class="tool-icon" data-tool="clear" data-tooltip="Ê∏ÖÁ©∫ÂÖ®ÈÉ®">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18M8 6V4h8v2m-9 4v10h10V10M10 14h4"/>
                </svg>
            </div>
            <div class="tool-separator"></div>
            <div class="tool-icon" data-tool="text-to-marker" data-tooltip="ÊñáÊú¨ËΩ¨Ê†áËØÜ">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/>
                    <path d="M14 2v6h6M16 13H8m8 4H8m2-8H8"/>
                    <circle cx="18" cy="18" r="3"/>
                    <path d="M18 16v4m-2-2h4"/>
                </svg>
            </div>
        </div>
    </div>

    <div id="location-panel">
        <h3 style="margin: 0 0 15px 0; color: #333; font-size: 16px;">‰ΩçÁΩÆÊêúÁ¥¢</h3>
        
        <!-- Âä†ËΩΩÊï∞ÊçÆÂ∫ìÊåâÈíÆ -->
        <div style="margin-bottom: 15px; padding: 10px; background: #f0f0f0; border-radius: 5px;">
            <label style="display: block; margin-bottom: 5px; font-size: 13px; color: #333;">ÊâπÈáèÂä†ËΩΩÊï∞ÊçÆÊñá‰ª∂:</label>
            <input type="file" id="db-file-input" accept=".json,.geojson" multiple style="display: none;">
            <button class="btn" id="load-db-btn" style="width: 100%;">ÈÄâÊã©JSONÊñá‰ª∂ÔºàÂèØÂ§öÈÄâÔºâ</button>
            <div id="db-status" style="margin-top: 5px; font-size: 11px; color: #666; text-align: center;"></div>
        </div>
        
        <!-- ÂõõÁ∫ßËÅîÂä®‰∏ãÊãâËèúÂçï -->
        <div class="location-select-group">
            <label>ÂõΩÂÆ∂</label>
            <select id="country-select" disabled>
                <option value="">ËØ∑ÂÖàÂä†ËΩΩÊï∞ÊçÆÂ∫ì</option>
            </select>
        </div>
        <div class="location-select-group">
            <label>Â∑û/ÁúÅ</label>
            <select id="state-select" disabled>
                <option value="">ËØ∑ÂÖàÈÄâÊã©ÂõΩÂÆ∂</option>
            </select>
        </div>
        <div class="location-select-group">
            <label>ÂüéÂ∏Ç</label>
            <select id="city-select" disabled>
                <option value="">ËØ∑ÂÖàÈÄâÊã©Â∑û/ÁúÅ</option>
            </select>
        </div>
        <button class="btn" id="go-location-btn" disabled style="width:100%; margin-bottom: 15px;">ÂÆö‰Ωç</button>
        
        <!-- ÊàñËÄÖÁõ¥Êé•ÊêúÁ¥¢ -->
        <div style="border-top: 1px solid #ddd; padding-top: 15px;">
            <label style="display: block; margin-bottom: 5px; font-size: 13px; font-weight: bold; color: #333;">ÊàñÁõ¥Êé•ÊêúÁ¥¢:</label>
            <input type="text" id="address-search-input" placeholder="ËæìÂÖ•ÂõΩÂÆ∂„ÄÅÂ∑û/ÁúÅÊàñÂüéÂ∏ÇÂêç..." style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px; margin-bottom: 10px;">
            <button class="btn" id="search-address-btn" disabled style="width:100%; margin-bottom: 10px;">ÊêúÁ¥¢</button>
        </div>
        
        <div id="search-results" style="max-height: 300px; overflow-y: auto; margin-bottom: 10px; display: none;">
            <label style="display: block; margin-bottom: 5px; font-size: 13px; font-weight: bold; color: #333;">ÊêúÁ¥¢ÁªìÊûú:</label>
            <div id="results-list" style="background: white; border: 1px solid #ddd; border-radius: 5px; max-height: 250px; overflow-y: auto;"></div>
        </div>
        
        <!-- ËæπÁïåÊéßÂà∂ -->
        <div class="boundary-controls">
            <label class="checkbox-label">
                <input type="checkbox" id="show-boundaries-checkbox" checked>
                ÊòæÁ§∫Ë°åÊîøÂå∫ÂàíËæπÁïå
            </label>
            <div id="boundary-status" style="margin-top: 5px; font-size: 11px; color: #666; text-align: center;"></div>
        </div>
        
        <div id="search-status" style="margin-top: 10px; font-size: 12px; color: #666; text-align: center;"></div>
    </div>

    <div id="file-controls">
        <div class="file-icon" id="save-btn" data-tooltip="‰øùÂ≠ò">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/>
                <path d="M17 21v-8H7v8M7 3v5h8"/>
            </svg>
        </div>
        <div class="file-icon" id="load-btn" data-tooltip="Âä†ËΩΩ">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M13 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V9z"/>
                <path d="M13 2v7h7"/>
            </svg>
        </div>
        <div class="tool-separator"></div>
        <div class="file-icon" id="settings-btn" data-tooltip="ËÆæÁΩÆ">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 1v6m0 6v6M4.22 4.22l4.24 4.24m5.08 5.08l4.24 4.24M1 12h6m6 0h6M4.22 19.78l4.24-4.24m5.08-5.08l4.24-4.24"/>
            </svg>
        </div>
        <input type="file" id="file-input" style="display:none;" accept=".json">
    </div>

    <div id="settings-panel">
        <div class="settings-header">
            <h3>‰∏ªÈ¢òËÆæÁΩÆ</h3>
            <span class="close-settings">‚úï</span>
        </div>
        <div class="setting-item">
            <label>ÊåâÈíÆÈ¢úËâ≤</label>
            <input type="color" id="theme-button-color" value="#666666">
        </div>
        <div class="setting-item">
            <label>Ê°ÜÂÜÖÂ°´ÂÖÖÈ¢úËâ≤</label>
            <input type="color" id="theme-fill-color" value="#ffffff">
        </div>
        <div class="setting-item">
            <label>Â°´ÂÖÖ‰∏çÈÄèÊòéÂ∫¶: <span class="opacity-value" id="fill-opacity-value">50%</span></label>
            <input type="range" id="theme-fill-opacity" min="0" max="100" value="50">
        </div>
    </div>

    <div id="text-to-marker-panel">
        <div class="text-to-marker-header">
            <h3>ÊñáÊú¨ËΩ¨Ê†áËØÜ</h3>
            <span class="close-text-to-marker">‚úï</span>
        </div>
        <div class="text-to-marker-example">
            Ê†ºÂºèÁ§∫‰æãÔºö‰∫ã‰ª∂ÂêçÁß∞ÔºõÊó∂Èó¥ÔºõÂú∞ÁÇπ‰∏ÄÔºõÂÖ≥Á≥ªÔºõÂú∞ÁÇπ‰∫å<br>
            ‰æãÂ¶ÇÔºö‰øÑ‰πåÂÜ≤Á™ÅÔºõ2022-02-24ÔºõUkraineÔºõinvasionÔºõRussia<br>
            ÂèØ‰ª•ËæìÂÖ•Â§öÊÆµÔºåÊØèÊÆµ‰∏ÄË°å
        </div>
        <textarea id="text-to-marker-input" placeholder="ËØ∑ËæìÂÖ•‰∫ã‰ª∂‰ø°ÊÅØ...&#10;Ê†ºÂºèÔºö‰∫ã‰ª∂ÂêçÁß∞ÔºõÊó∂Èó¥ÔºõÂú∞ÁÇπ‰∏ÄÔºõÂÖ≥Á≥ªÔºõÂú∞ÁÇπ‰∫å&#10;ÂèØÂ§öË°åËæìÂÖ•"></textarea>
        <div class="text-to-marker-options">
            <label>
                <input type="checkbox" id="option-show-boundaries" checked>
                ÊòæÁ§∫ËæπÁïå
            </label>
            <label>
                <input type="radio" name="arrow-type" value="line" checked>
                Áõ¥Á∫ø
            </label>
            <label>
                <input type="radio" name="arrow-type" value="dashed">
                ËôöÁ∫ø
            </label>
            <label>
                <input type="radio" name="arrow-type" value="arrow">
                ÁÆ≠Â§¥
            </label>
            <label>
                <input type="radio" name="arrow-type" value="chevron">
                Èõ™‰ΩõÈæôÁÆ≠Â§¥
            </label>
        </div>
        <div class="text-to-marker-buttons">
            <button class="btn-parse">Ëß£ÊûêÂπ∂ÁîüÊàê</button>
            <button class="btn-cancel">ÂèñÊ∂à</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            
            const map = L.map('map', {
                center: [20, 0],
                zoom: 2,
                minZoom: 2,
                maxZoom: 18,
                doubleClickZoom: false,
                worldCopyJump: true,
                maxBounds: [[-85, -Infinity], [85, Infinity]]
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap',
                maxZoom: 18
            }).addTo(map);

            // ËæπÁïåÂõæÂ±Ç
            let boundaryLayers = L.layerGroup().addTo(map);
            let allBoundaries = []; // Â≠òÂÇ®ÊâÄÊúâËæπÁïåÂØπË±°

            let currentTool = 'pan';
            let drawingState = {
                isDrawing: false,
                startPoint: null,
                points: [],
                previewLayer: null,
                tempMarker: null,
                dashedSegments: []
            };

            let eraserState = {
                isErasing: false
            };

            let currentDate = new Date(2025, 0, 1); 
            let calendarDate = new Date(2025, 0, 1);

            const dateDisplayEl = document.getElementById('date-display');
            const calendarContainer = document.getElementById('calendar-container');
            const yearSelect = document.getElementById('year-select');
            const monthSelect = document.getElementById('month-select');
            const prevMonthBtn = document.getElementById('prev-month');
            const nextMonthBtn = document.getElementById('next-month');
            const calendarDays = document.getElementById('calendar-days');
            
            const toolOptions = {
                annotate: { 
                    markerType: 'none',
                    lineStyle: 'solid',
                    lineType: 'straight',
                    color: '#ff0000',
                    weight: 3,
                    opacity: 1,
                    arrowText: ''
                },
                text: { bgColor: '#ffffff', textColor: '#000000', opacity: 1 }
            };

            const annotations = {
                markers: [],
                lines: [],
                arrows: [],
                textBoxes: [],
                events: [] // Êñ∞Â¢ûÔºö‰∫ã‰ª∂Êï∞ÊçÆ
            };

            let locationState = {
                currentLocation: null
            };

            let geoDatabase = [];
            let databaseLoaded = false;
            let localGeoJSONFiles = {}; // Â≠òÂÇ®Êú¨Âú∞GeoJSONÊñá‰ª∂ {name: geojsonData}

            function showSearchStatus(message, isError = false) {
                const statusEl = document.getElementById('search-status');
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.style.color = isError ? '#f44336' : '#666';
                }
            }

            function showDbStatus(message, isError = false) {
                const statusEl = document.getElementById('db-status');
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.style.color = isError ? '#f44336' : '#4CAF50';
                }
            }

            function showBoundaryStatus(message, isError = false) {
                const statusEl = document.getElementById('boundary-status');
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.style.color = isError ? '#f44336' : '#4CAF50';
                }
            }

            // Ëã±ÊñáÁúÅ‰ªΩÂêçÂà∞‰∏≠ÊñáÁöÑÊò†Â∞Ñ
            const provinceNameMap = {
                'beijing': 'Âåó‰∫¨',
                'tianjin': 'Â§©Ê¥•',
                'hebei': 'Ê≤≥Âåó',
                'shanxi': 'Â±±Ë•ø',
                'inner mongolia': 'ÂÜÖËíôÂè§',
                'liaoning': 'ËæΩÂÆÅ',
                'jilin': 'ÂêâÊûó',
                'heilongjiang': 'ÈªëÈæôÊ±ü',
                'shanghai': '‰∏äÊµ∑',
                'jiangsu': 'Ê±üËãè',
                'zhejiang': 'ÊµôÊ±ü',
                'anhui': 'ÂÆâÂæΩ',
                'fujian': 'Á¶èÂª∫',
                'jiangxi': 'Ê±üË•ø',
                'shandong': 'Â±±‰∏ú',
                'henan': 'Ê≤≥Âçó',
                'hubei': 'ÊπñÂåó',
                'hunan': 'ÊπñÂçó',
                'guangdong': 'Âπø‰∏ú',
                'guangxi': 'ÂπøË•ø',
                'hainan': 'Êµ∑Âçó',
                'chongqing': 'ÈáçÂ∫Ü',
                'sichuan': 'ÂõõÂ∑ù',
                'guizhou': 'Ë¥µÂ∑û',
                'yunnan': '‰∫ëÂçó',
                'tibet': 'Ë•øËóè',
                'shaanxi': 'ÈôïË•ø',
                'gansu': 'ÁîòËÇÉ',
                'qinghai': 'ÈùíÊµ∑',
                'ningxia': 'ÂÆÅÂ§è',
                'xinjiang': 'Êñ∞ÁñÜ',
                'taiwan': 'Âè∞Êπæ',
                'hongkong': 'È¶ôÊ∏Ø',
                'hong kong': 'È¶ôÊ∏Ø',
                'macau': 'Êæ≥Èó®',
                'macao': 'Êæ≥Èó®'
            };

            // ‰ªé‰∏≠ÂõΩGeoJSON‰∏≠ÊèêÂèñÁâπÂÆöÂå∫ÂüüÁöÑËæπÁïå
            function extractChinaRegionBoundary(geojsonData, regionName, regionType) {
                console.log(`Â∞ùËØïÊèêÂèñÂå∫Âüü: ${regionName}, Á±ªÂûã: ${regionType}`);
                
                if (!geojsonData || !geojsonData.features) {
                    console.error('GeoJSONÊï∞ÊçÆÊ†ºÂºè‰∏çÊ≠£Á°Æ');
                    return null;
                }
                
                // ËßÑËåÉÂåñÊêúÁ¥¢ÂêçÁß∞
                let searchNames = [regionName];
                const regionNameLower = regionName.toLowerCase();
                
                // Â¶ÇÊûúÊòØËã±ÊñáÂêçÔºåÊ∑ªÂä†ÂØπÂ∫îÁöÑ‰∏≠ÊñáÂêç
                if (provinceNameMap[regionNameLower]) {
                    searchNames.push(provinceNameMap[regionNameLower]);
                    searchNames.push(provinceNameMap[regionNameLower] + 'ÁúÅ');
                    searchNames.push(provinceNameMap[regionNameLower] + 'Â∏Ç');
                }
                
                // ‰πüÊ∑ªÂä†ÂéªÊéâ"ÁúÅ"„ÄÅ"Â∏Ç"„ÄÅ"Ëá™Ê≤ªÂå∫"ÂêéÁºÄÁöÑÁâàÊú¨
                searchNames.push(regionName.replace(/[ÁúÅÂ∏ÇËá™Ê≤ªÂå∫]/g, ''));
                
                console.log('ÊêúÁ¥¢ÂêçÁß∞ÂàóË°®:', searchNames);
                
                // Êü•ÊâæÂåπÈÖçÁöÑFeature
                const feature = geojsonData.features.find(f => {
                    const properties = f.properties || {};
                    const name = properties.name || properties.NAME || properties.ÂêçÁß∞ || '';
                    
                    // Â∞ùËØïÂ§öÁßçÂ±ûÊÄßÂêçÁß∞
                    const possibleNames = [
                        name,
                        properties.NAME_CHN,
                        properties.province,
                        properties.city,
                        properties.adcode99,
                        properties.ÁúÅ,
                        properties.Â∏Ç,
                        properties.NL_NAME_1,
                        properties.NAME_1
                    ].filter(Boolean);
                    
                    // Ê£ÄÊü•ÊòØÂê¶ÂåπÈÖç‰ªª‰ΩïÊêúÁ¥¢ÂêçÁß∞
                    return searchNames.some(searchName => {
                        return possibleNames.some(pName => {
                            const pNameStr = String(pName).toLowerCase();
                            const searchNameLower = searchName.toLowerCase();
                            
                            // ÂÆåÂÖ®ÂåπÈÖç
                            if (pNameStr === searchNameLower) return true;
                            
                            // ÂåÖÂê´ÂåπÈÖç
                            if (pNameStr.includes(searchNameLower)) return true;
                            if (searchNameLower.includes(pNameStr)) return true;
                            
                            // ÂéªÊéâÁúÅÂ∏ÇÂêéÁºÄÂÜçÂåπÈÖç
                            const pNameClean = pNameStr.replace(/[ÁúÅÂ∏ÇËá™Ê≤ªÂå∫]/g, '');
                            const searchNameClean = searchNameLower.replace(/[ÁúÅÂ∏ÇËá™Ê≤ªÂå∫]/g, '');
                            if (pNameClean === searchNameClean) return true;
                            
                            return false;
                        });
                    });
                });
                
                if (feature) {
                    console.log('ÊâæÂà∞ÂåπÈÖçÁöÑÂå∫Âüü:', feature.properties);
                    // ËøîÂõûÂçï‰∏™Feature‰Ωú‰∏∫Êñ∞ÁöÑGeoJSON
                    return {
                        type: 'FeatureCollection',
                        features: [feature]
                    };
                } else {
                    console.warn(`Êú™ÊâæÂà∞Âå∫Âüü: ${regionName}`);
                    console.log('ÂèØÁî®ÁöÑÂå∫Âüü:', geojsonData.features.slice(0, 10).map(f => 
                        f.properties?.name || f.properties?.NAME || 'Êú™Áü•'
                    ));
                    console.log('ÊÄªÂÖ±Êúâ', geojsonData.features.length, '‰∏™Âå∫Âüü');
                    return null;
                }
            }
            
            // ‰ªéÊú¨Âú∞ÊàñAPIËé∑ÂèñËæπÁïå
            async function fetchBoundaryFromNominatim(location) {
                try {
                    const locationNameLower = (location.displayName || location.name).toLowerCase();
                    
                    // Ê£ÄÊü•ÊòØÂê¶ÊòØ‰∏≠ÂõΩÁõ∏ÂÖ≥Êü•ËØ¢
                    const isChinaQuery = locationNameLower.includes('china') || 
                                        locationNameLower.includes('‰∏≠ÂõΩ') ||
                                        locationNameLower.includes('‰∏≠Âçé‰∫∫Ê∞ëÂÖ±ÂíåÂõΩ');
                    
                    // Ê£ÄÊü•ÊòØÂê¶ÊòØ‰∏≠ÂõΩÁöÑÁúÅ‰ªΩÊàñÂüéÂ∏ÇÊü•ËØ¢
                    const isChinaRegion = location.parentCountry === 'China' || 
                                         location.country === 'China' ||
                                         (location.type === 'state' || location.type === 'city') && 
                                         (location.displayName?.includes('‰∏≠ÂõΩ') || location.countryName === 'China');
                    
                    if (isChinaQuery || isChinaRegion) {
                        console.log('Ê£ÄÊµãÂà∞‰∏≠ÂõΩÊü•ËØ¢Ôºå‰ΩøÁî®Êú¨Âú∞GeoJSONÊñá‰ª∂');
                        console.log('‰ΩçÁΩÆ‰ø°ÊÅØ:', location);
                        console.log('ÂèØÁî®ÁöÑÊú¨Âú∞Êñá‰ª∂:', Object.keys(localGeoJSONFiles));
                        
                        // Êü•ÊâæÊú¨Âú∞‰∏≠ÂõΩGeoJSONÊñá‰ª∂
                        const chinaKey = Object.keys(localGeoJSONFiles).find(key => {
                            const keyLower = key.toLowerCase();
                            return keyLower.includes('china') || 
                                   key.includes('‰∏≠ÂõΩ') ||
                                   key.includes('‰∏≠Âçé‰∫∫Ê∞ëÂÖ±ÂíåÂõΩ');
                        });
                        
                        if (chinaKey) {
                            console.log('ÊâæÂà∞Êú¨Âú∞‰∏≠ÂõΩÊñá‰ª∂:', chinaKey);
                            showBoundaryStatus('‰ΩøÁî®Êú¨Âú∞‰∏≠ÂõΩËæπÁïåÊñá‰ª∂...');
                            
                            let geojsonData = localGeoJSONFiles[chinaKey];
                            let boundaryName = '‰∏≠Âçé‰∫∫Ê∞ëÂÖ±ÂíåÂõΩ';
                            let isFullChina = true;
                            
                            // Â¶ÇÊûúÊòØÁúÅ‰ªΩÊàñÂüéÂ∏ÇÔºåÊèêÂèñÁâπÂÆöÂå∫Âüü
                            if (location.type === 'state' || location.type === 'city') {
                                const regionName = location.name;
                                const extractedRegion = extractChinaRegionBoundary(
                                    geojsonData, 
                                    regionName, 
                                    location.type
                                );
                                
                                if (extractedRegion) {
                                    geojsonData = extractedRegion;
                                    boundaryName = regionName;
                                    isFullChina = false;
                                    console.log('ÊàêÂäüÊèêÂèñÂå∫ÂüüËæπÁïå:', regionName);
                                } else {
                                    // Â¶ÇÊûúÊâæ‰∏çÂà∞ÁâπÂÆöÂå∫ÂüüÔºåÊòæÁ§∫Êï¥‰∏™‰∏≠ÂõΩ
                                    console.warn('Êú™ÊâæÂà∞ÁâπÂÆöÂå∫ÂüüÔºåÊòæÁ§∫Êï¥‰∏™‰∏≠ÂõΩËæπÁïå');
                                    showBoundaryStatus('Êú™ÊâæÂà∞ËØ•Âå∫ÂüüËæπÁïåÔºåÊòæÁ§∫Êï¥‰∏™‰∏≠ÂõΩ', true);
                                }
                            }
                            
                            // ÂàõÂª∫ÂõæÂ±ÇÔºåÊ†πÊçÆÊòØÂê¶ÊòØÂÆåÊï¥‰∏≠ÂõΩÊù•ÂÜ≥ÂÆöÊ†∑Âºè
                            const layer = L.geoJSON(geojsonData, {
                                style: function(feature) {
                                    if (isFullChina) {
                                        // ÂÆåÊï¥‰∏≠ÂõΩÔºöÂè™ÊòæÁ§∫Â§ñËΩÆÂªìÔºå‰∏çÊòæÁ§∫ÂÜÖÈÉ®ÁúÅÁïå
                                        return {
                                            color: '#ff0000',
                                            weight: 2,
                                            opacity: 0.8,
                                            fillColor: '#ff0000',
                                            fillOpacity: 0.1,
                                            // ÂÖ≥ÈîÆÔºö‰ΩøÁî®strokeÊù•Âè™ÊòæÁ§∫Â§ñËæπÁïå
                                            fill: true
                                        };
                                    } else {
                                        // Âçï‰∏™ÁúÅ‰ªΩÔºöÊòæÁ§∫ËæπÁïå
                                        return {
                                            color: '#ff0000',
                                            weight: 2,
                                            opacity: 0.8,
                                            fillColor: '#ff0000',
                                            fillOpacity: 0.1
                                        };
                                    }
                                },
                                // ÂØπ‰∫éÂÆåÊï¥‰∏≠ÂõΩÔºåÂêàÂπ∂ÊâÄÊúâfeatures‰∏∫‰∏Ä‰∏™Êï¥‰Ωì
                                onEachFeature: isFullChina ? null : undefined
                            });
                            
                            const boundaryObj = {
                                name: boundaryName,
                                layer: layer,
                                visible: true,
                                type: 'local'
                            };
                            
                            allBoundaries.push(boundaryObj);
                            
                            const showCheckbox = document.getElementById('show-boundaries-checkbox');
                            if (showCheckbox && showCheckbox.checked) {
                                boundaryLayers.addLayer(layer);
                            }
                            
                            updateLayersPanel();
                            showBoundaryStatus('‚úì Êú¨Âú∞ËæπÁïåÂä†ËΩΩÊàêÂäü');
                            
                            setTimeout(() => {
                                showBoundaryStatus('');
                            }, 3000);
                            
                            return layer;
                        } else {
                            // Ê≤°ÊúâÊâæÂà∞Êú¨Âú∞Êñá‰ª∂Ôºå‰∏çË∞ÉÁî®APIÔºåÊèêÁ§∫Áî®Êà∑
                            console.error('Êú™ÊâæÂà∞Êú¨Âú∞‰∏≠ÂõΩGeoJSONÊñá‰ª∂');
                            showBoundaryStatus('ËØ∑ÂÖà‰∏ä‰º†‰∏≠ÂõΩGeoJSONËæπÁïåÊñá‰ª∂', true);
                            alert('Êú™ÊâæÂà∞‰∏≠ÂõΩËæπÁïåÊñá‰ª∂ÔºÅ\n\nËØ∑Âú®"ÊâπÈáèÂä†ËΩΩÊï∞ÊçÆÊñá‰ª∂"Â§Ñ‰∏ä‰º†ÂåÖÂê´‰∏≠ÂõΩËæπÁïåÁöÑGeoJSONÊñá‰ª∂„ÄÇ\nÊñá‰ª∂ÂêçÂ∫îÂåÖÂê´"‰∏≠ÂõΩ"„ÄÅ"‰∏≠Âçé‰∫∫Ê∞ëÂÖ±ÂíåÂõΩ"Êàñ"china"„ÄÇ');
                            setTimeout(() => {
                                showBoundaryStatus('');
                            }, 5000);
                            return null;
                        }
                    }
                    
                    // Èùû‰∏≠ÂõΩÊü•ËØ¢Ôºå‰ΩøÁî®API
                    showBoundaryStatus('Ê≠£Âú®Âä†ËΩΩËæπÁïåÊï∞ÊçÆ...');
                    
                    let query = location.displayName || location.name;
                    
                    const searchUrl = `https://nominatim.openstreetmap.org/search?` + 
                        `q=${encodeURIComponent(query)}&` +
                        `format=json&` +
                        `polygon_geojson=1&` +
                        `limit=1`;
                    
                    const response = await fetch(searchUrl, {
                        headers: {
                            'User-Agent': 'WorldSituationMap/1.0'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error('API ËØ∑Ê±ÇÂ§±Ë¥•');
                    }
                    
                    const data = await response.json();
                    
                    if (data && data.length > 0 && data[0].geojson) {
                        const geojson = data[0].geojson;
                        
                        const layer = L.geoJSON(geojson, {
                            style: {
                                color: '#ff0000',
                                weight: 2,
                                opacity: 0.8,
                                fillColor: '#ff0000',
                                fillOpacity: 0.1
                            }
                        });
                        
                        const boundaryObj = {
                            name: location.displayName || location.name,
                            layer: layer,
                            visible: true,
                            type: location.type || 'unknown'
                        };
                        
                        allBoundaries.push(boundaryObj);
                        
                        const showCheckbox = document.getElementById('show-boundaries-checkbox');
                        if (showCheckbox && showCheckbox.checked) {
                            boundaryLayers.addLayer(layer);
                        }
                        
                        updateLayersPanel();
                        showBoundaryStatus('‚úì ËæπÁïåÂä†ËΩΩÊàêÂäü');
                        
                        setTimeout(() => {
                            showBoundaryStatus('');
                        }, 3000);
                        
                        return layer;
                    } else {
                        showBoundaryStatus('ËØ•Âú∞Âå∫ÊöÇÊó†ËæπÁïåÊï∞ÊçÆ', true);
                        setTimeout(() => {
                            showBoundaryStatus('');
                        }, 3000);
                        return null;
                    }
                } catch (error) {
                    console.error('Ëé∑ÂèñËæπÁïåÂ§±Ë¥•:', error);
                    showBoundaryStatus('ËæπÁïåÂä†ËΩΩÂ§±Ë¥•', true);
                    setTimeout(() => {
                        showBoundaryStatus('');
                    }, 3000);
                    return null;
                }
            }

            // Ëé∑ÂèñÂ§ö‰∏™ËæπÁïåÂπ∂ÂêàÂπ∂ÊòæÁ§∫
            async function fetchMultipleBoundaries(locationNames) {
                try {
                    showBoundaryStatus('Ê≠£Âú®Âä†ËΩΩËæπÁïåÊï∞ÊçÆ...');
                    
                    for (const name of locationNames) {
                        const searchUrl = `https://nominatim.openstreetmap.org/search?` + 
                            `q=${encodeURIComponent(name)}&` +
                            `format=json&` +
                            `polygon_geojson=1&` +
                            `limit=1`;
                        
                        try {
                            const response = await fetch(searchUrl, {
                                headers: {
                                    'User-Agent': 'WorldSituationMap/1.0'
                                }
                            });
                            
                            if (response.ok) {
                                const data = await response.json();
                                if (data && data.length > 0 && data[0].geojson) {
                                    const layer = L.geoJSON(data[0].geojson, {
                                        style: {
                                            color: '#ff0000',
                                            weight: 2,
                                            opacity: 0.8,
                                            fillColor: '#ff0000',
                                            fillOpacity: 0.1
                                        }
                                    });
                                    
                                    const boundaryObj = {
                                        name: name,
                                        layer: layer,
                                        visible: true,
                                        type: 'region'
                                    };
                                    
                                    allBoundaries.push(boundaryObj);
                                    
                                    const showCheckbox = document.getElementById('show-boundaries-checkbox');
                                    if (showCheckbox && showCheckbox.checked) {
                                        boundaryLayers.addLayer(layer);
                                    }
                                }
                            }
                            
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            
                        } catch (error) {
                            console.error(`Ëé∑Âèñ ${name} ËæπÁïåÂ§±Ë¥•:`, error);
                        }
                    }
                    
                    if (allBoundaries.length > 0) {
                        updateLayersPanel();
                        showBoundaryStatus(`‚úì Â∑≤Âä†ËΩΩÂÆåÊï¥ËæπÁïå`);
                        
                        setTimeout(() => {
                            showBoundaryStatus('');
                        }, 3000);
                    } else {
                        showBoundaryStatus('Êú™ÊâæÂà∞ËæπÁïåÊï∞ÊçÆ', true);
                        setTimeout(() => {
                            showBoundaryStatus('');
                        }, 3000);
                    }
                    
                } catch (error) {
                    console.error('Ëé∑ÂèñËæπÁïåÂ§±Ë¥•:', error);
                    showBoundaryStatus('ËæπÁïåÂä†ËΩΩÂ§±Ë¥•', true);
                    setTimeout(() => {
                        showBoundaryStatus('');
                    }, 3000);
                }
            }

            // ËæπÁïåÊòæÁ§∫ÊéßÂà∂
            document.getElementById('show-boundaries-checkbox').addEventListener('change', function() {
                if (this.checked) {
                    allBoundaries.forEach(b => {
                        if (b.visible && b.layer) {
                            boundaryLayers.addLayer(b.layer);
                        }
                    });
                } else {
                    boundaryLayers.clearLayers();
                }
            });

            // ÊñáÊú¨ËΩ¨Ê†áËØÜÂäüËÉΩ
            function initTextToMarker() {
                const textToMarkerBtn = document.querySelector('[data-tool="text-to-marker"]');
                const panel = document.getElementById('text-to-marker-panel');
                const closeBtn = document.querySelector('.close-text-to-marker');
                const cancelBtn = document.querySelector('.btn-cancel');
                const parseBtn = document.querySelector('.btn-parse');
                const textInput = document.getElementById('text-to-marker-input');

                if (!textToMarkerBtn) return;

                // ÊâìÂºÄÈù¢Êùø
                textToMarkerBtn.addEventListener('click', () => {
                    panel.classList.add('show');
                });

                // ÂÖ≥Èó≠Èù¢Êùø
                closeBtn.addEventListener('click', () => {
                    panel.classList.remove('show');
                });

                cancelBtn.addEventListener('click', () => {
                    panel.classList.remove('show');
                });

                // Ëß£ÊûêÂπ∂ÁîüÊàê
                parseBtn.addEventListener('click', async () => {
                    const text = textInput.value.trim();
                    if (!text) {
                        alert('ËØ∑ËæìÂÖ•‰∫ã‰ª∂‰ø°ÊÅØ');
                        return;
                    }

                    const showBoundaries = document.getElementById('option-show-boundaries').checked;
                    const arrowType = document.querySelector('input[name="arrow-type"]:checked').value;

                    // Ëß£ÊûêÊñáÊú¨
                    const events = parseEventsText(text);
                    if (events.length === 0) {
                        alert('Êú™ËÉΩËß£Êûê‰ªª‰Ωï‰∫ã‰ª∂ÔºåËØ∑Ê£ÄÊü•Ê†ºÂºè');
                        return;
                    }

                    // Â§ÑÁêÜÊØè‰∏™‰∫ã‰ª∂
                    for (const event of events) {
                        await processEvent(event, showBoundaries, arrowType);
                    }

                    panel.classList.remove('show');
                    textInput.value = '';
                    updateLayersPanel();
                    alert(`ÊàêÂäüÁîüÊàê ${events.length} ‰∏™‰∫ã‰ª∂`);
                });
            }

            // Ëß£Êûê‰∫ã‰ª∂ÊñáÊú¨
            function parseEventsText(text) {
                const lines = text.split('\n').filter(line => line.trim());
                const events = [];

                for (const line of lines) {
                    const parts = line.split(/[Ôºõ;]/).map(p => p.trim());
                    if (parts.length === 5) {
                        events.push({
                            name: parts[0],
                            time: parts[1],
                            location1: parts[2],
                            relation: parts[3],
                            location2: parts[4]
                        });
                    }
                }

                return events;
            }

            // Â§ÑÁêÜÂçï‰∏™‰∫ã‰ª∂
            async function processEvent(event, showBoundaries, arrowType) {
                console.log('Â§ÑÁêÜ‰∫ã‰ª∂:', event);

                // ÊêúÁ¥¢Âú∞ÁÇπÂùêÊ†á
                const loc1 = await searchLocation(event.location1);
                const loc2 = await searchLocation(event.location2);
                console.log("loc1 ÂùêÊ†á:", event.location1, loc1);
                console.log("loc2 ÂùêÊ†á:", event.location2, loc2);


                if (!loc1 || !loc2) {
                    console.error('Êó†Ê≥ïÊâæÂà∞Âú∞ÁÇπÂùêÊ†á:', event);
                    alert(`Êó†Ê≥ïÊâæÂà∞Âú∞ÁÇπ: ${!loc1 ? event.location1 : event.location2}`);
                    return;
                }

                const eventData = {
                    name: event.name,
                    time: event.time,
                    location1: event.location1,
                    relation: event.relation,
                    location2: event.location2,
                    loc1Coords: loc1,
                    loc2Coords: loc2,
                    date: new Date(currentDate),
                    boundaries: [],
                    connections: []
                };

                // Ê∑ªÂä†ËæπÁïå
                if (showBoundaries) {
                    const boundary1 = await fetchBoundaryFromNominatim({
                        name: event.location1,
                        displayName: event.location1,
                        type: loc1.type
                    });
                    if (boundary1) {
                        eventData.boundaries.push({
                            location: event.location1,
                            layer: boundary1
                        });
                    }

                    await new Promise(resolve => setTimeout(resolve, 1000));

                    const boundary2 = await fetchBoundaryFromNominatim({
                        name: event.location2,
                        displayName: event.location2,
                        type: loc2.type
                    });
                    if (boundary2) {
                        eventData.boundaries.push({
                            location: event.location2,
                            layer: boundary2
                        });
                    }
                }
                // ÂàõÂª∫ËøûÊé•Á∫ø - ‰∏∫‰∏§ÁÇπÊ∑ªÂä†‰∏≠Èó¥ÊéßÂà∂ÁÇπ
                const midLat = (loc1.latitude + loc2.latitude) / 2;
                const midLng = (loc1.longitude + loc2.longitude) / 2;
                
                // ËÆ°ÁÆóÂûÇÁõ¥ÂÅèÁßªÔºåÂàõÂª∫ÂºßÂΩ¢
                const latDiff = loc2.latitude - loc1.latitude;
                const lngDiff = loc2.longitude - loc1.longitude;
                const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                const offset = distance * 0.001; // ÂÅèÁßªÈáè‰∏∫Ë∑ùÁ¶ªÁöÑ30%
                
                // ÂûÇÁõ¥‰∫éËøûÁ∫øÊñπÂêëÁöÑÂÅèÁßª
                const perpLat = -lngDiff / distance * offset;
                const perpLng = latDiff / distance * offset;
                
                const points = [
                    L.latLng(loc1.latitude, loc1.longitude),
                    L.latLng(midLat + perpLat, midLng + perpLng), // ‰∏≠Èó¥ÊéßÂà∂ÁÇπ
                    L.latLng(loc2.latitude, loc2.longitude)
                ];

                const lineOptions = {
                    lineType: 'bezier',
                    color: '#ff0000',
                    weight: 3,
                    opacity: 1,
                    arrowText: event.relation
                };

                let connectionLayer;
                if (arrowType === 'line') {
                    lineOptions.lineStyle = 'solid';
                    connectionLayer = createLine(points, lineOptions);
                    eventData.connections.push({
                        layer: connectionLayer,
                        type: 'line'
                    });
                } else if (arrowType === 'dashed') {
                    lineOptions.lineStyle = 'dashed';
                    connectionLayer = createLine(points, lineOptions);
                    eventData.connections.push({
                        layer: connectionLayer,
                        type: 'line'
                    });
                } else if (arrowType === 'arrow') {
                    const arrow = createArrow(points, lineOptions);
                    arrow.layer.addTo(map);
                    eventData.connections.push(arrow);
                } else if (arrowType === 'chevron') {
                    const chevron = createChevron(points, lineOptions, map);
                    chevron.layer.addTo(map);
                    eventData.connections.push(chevron);
                }

                // Â¶ÇÊûúÊòØlineÊàñdashedÔºåÊ∑ªÂä†Âà∞Âú∞Âõæ
                if (arrowType === 'line' || arrowType === 'dashed') {
                    eventData.connections[0].layer.addTo(map);
                }

                annotations.events.push(eventData);
            }
// ÊêúÁ¥¢Âú∞ÁÇπÂùêÊ†á (Êñ∞ÁâàÊú¨ÔºåÊîØÊåÅÂ±ÇÁ∫ßÊêúÁ¥¢)
            async function searchLocation(locationName) {
                if (!databaseLoaded) {
                    console.error('Êï∞ÊçÆÂ∫ìÊú™Âä†ËΩΩ');
                    return null;
                }

                // 1. Â∞ÜÊêúÁ¥¢Â≠óÁ¨¶‰∏≤ÊåâÈÄóÂè∑ÂàÜÂâ≤ÔºåÂπ∂Ê∏ÖÁêÜÁ©∫Ê†ºÂíåËΩ¨Êç¢‰∏∫Â∞èÂÜô
                const parts = locationName.split(',').map(p => p.trim().toLowerCase());
                
                // 2. Â§ÑÁêÜ‰∏âÊÆµÂºèÊêúÁ¥¢: "ÂõΩÂÆ∂, ÁúÅ‰ªΩ, ÂüéÂ∏Ç"
                if (parts.length === 3) {
                    const [countryName, stateName, cityName] = parts;
                    const country = geoDatabase.find(c => c.name.toLowerCase() === countryName);
                    if (country?.states) {
                        const state = country.states.find(s => s.name.toLowerCase() === stateName);
                        if (state?.cities) {
                            const city = state.cities.find(c => c.name.toLowerCase() === cityName);
                            if (city) {
                                console.log(`Found City: ${city.name} in ${state.name}, ${country.name}`);
                                return { latitude: parseFloat(city.latitude), longitude: parseFloat(city.longitude), type: 'city', zoom: 11 };
                            }
                        }
                    }
                }

                // 3. Â§ÑÁêÜ‰∏§ÊÆµÂºèÊêúÁ¥¢: "ÂõΩÂÆ∂, ÁúÅ‰ªΩ" Êàñ "ÁúÅ‰ªΩ, ÂüéÂ∏Ç"
                if (parts.length === 2) {
                    const [parentName, childName] = parts;

                    // ‰ºòÂÖàÂ∞ùËØï "ÂõΩÂÆ∂, ÁúÅ‰ªΩ"
                    const countryAsParent = geoDatabase.find(c => c.name.toLowerCase() === parentName);
                    if (countryAsParent?.states) {
                        const state = countryAsParent.states.find(s => s.name.toLowerCase() === childName);
                        if (state) {
                             console.log(`Found State: ${state.name} in ${countryAsParent.name}`);
                            return { latitude: parseFloat(state.latitude), longitude: parseFloat(state.longitude), type: 'state', zoom: 7 };
                        }
                    }

                    // Â¶ÇÊûúÊâæ‰∏çÂà∞ÔºåÂàôÂú®ÊâÄÊúâÊï∞ÊçÆ‰∏≠Â∞ùËØï "ÁúÅ‰ªΩ, ÂüéÂ∏Ç"
                    for (const country of geoDatabase) {
                        if (country.states) {
                            const stateAsParent = country.states.find(s => s.name.toLowerCase() === parentName);
                            if (stateAsParent?.cities) {
                                const city = stateAsParent.cities.find(c => c.name.toLowerCase() === childName);
                                if (city) {
                                    console.log(`Found City: ${city.name} in ${stateAsParent.name}`);
                                    return { latitude: parseFloat(city.latitude), longitude: parseFloat(city.longitude), type: 'city', zoom: 11 };
                                }
                            }
                        }
                    }
                }

                // 4. Â§ÑÁêÜÂçïÊÆµÂºèÊêúÁ¥¢: "ÂõΩÂÆ∂" Êàñ "ÁúÅ‰ªΩ"
                if (parts.length === 1) {
                    const searchTerm = parts[0];
                    
                    // ‰ºòÂÖàËøõË°åÁ≤æÁ°ÆÁöÑÂõΩÂÆ∂ÂêçÁß∞ÂåπÈÖç
                    const country = geoDatabase.find(c => c.name.toLowerCase() === searchTerm);
                    if (country) {
                        console.log(`Found Country: ${country.name}`);
                        return { latitude: parseFloat(country.latitude), longitude: parseFloat(country.longitude), type: 'country', zoom: 5 };
                    }

                    // Â¶ÇÊûú‰∏çÊòØÂõΩÂÆ∂ÔºåÂÜçÁ≤æÁ°ÆÂåπÈÖçÁúÅ‰ªΩÂêçÁß∞
                    for (const c of geoDatabase) {
                        if (c.states) {
                            const state = c.states.find(s => s.name.toLowerCase() === searchTerm);
                            if (state) {
                                console.log(`Found State: ${state.name}`);
                                return { latitude: parseFloat(state.latitude), longitude: parseFloat(state.longitude), type: 'state', zoom: 7 };
                            }
                        }
                    }
                }

                // 5. Â¶ÇÊûúÊâÄÊúâÁ≤æÁ°ÆÊêúÁ¥¢ÈÉΩÂ§±Ë¥•ÔºåÂàôËøîÂõû null
                console.warn(`'${locationName}' could not be found with a structured search. Returning null.`);
                return null;
            }
            // Âà†Èô§‰∫ã‰ª∂
            function deleteEvent(eventIndex) {
                const event = annotations.events[eventIndex];
                
                // Âà†Èô§ËæπÁïå
                event.boundaries.forEach(b => {
                    if (b.layer) {
                        boundaryLayers.removeLayer(b.layer);
                        allBoundaries = allBoundaries.filter(ab => ab.layer !== b.layer);
                    }
                });

                // Âà†Èô§ËøûÊé•Á∫ø
                event.connections.forEach(c => {
                    if (c.layer) {
                        map.removeLayer(c.layer);
                    }
                });

                annotations.events.splice(eventIndex, 1);
                updateLayersPanel();
            }

            // GeoJSONÊñá‰ª∂‰∏ä‰º†ÂäüËÉΩ
            function initGeoJSONUpload() {
                const uploadBtn = document.getElementById('upload-geojson-btn');
                const fileInput = document.getElementById('geojson-file-input');
                
                // ÂäüËÉΩÂ∑≤ÁßªÈô§Ôºå‰øùÁïôÁ©∫ÂáΩÊï∞ÈÅøÂÖçÈîôËØØ
                if (!uploadBtn || !fileInput) return;

                uploadBtn.addEventListener('click', () => {
                    fileInput.click();
                });

                fileInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            const geojsonData = JSON.parse(event.target.result);
                            
                            const layer = L.geoJSON(geojsonData, {
                                style: {
                                    color: '#2196F3',
                                    weight: 2,
                                    opacity: 0.8,
                                    fillColor: '#2196F3',
                                    fillOpacity: 0.15
                                }
                            });

                            const boundaryObj = {
                                name: file.name.replace('.json', '').replace('.geojson', ''),
                                layer: layer,
                                visible: true,
                                type: 'geojson'
                            };

                            allBoundaries.push(boundaryObj);

                            const showCheckbox = document.getElementById('show-boundaries-checkbox');
                            if (showCheckbox && showCheckbox.checked) {
                                boundaryLayers.addLayer(layer);
                            }

                            map.fitBounds(layer.getBounds());

                            updateLayersPanel();
                            alert('GeoJSONÊñá‰ª∂Âä†ËΩΩÊàêÂäüÔºÅ');
                        } catch (error) {
                            console.error('GeoJSONËß£ÊûêÂ§±Ë¥•:', error);
                            alert('Êñá‰ª∂Ê†ºÂºèÈîôËØØÔºåËØ∑ÈÄâÊã©ÊúâÊïàÁöÑGeoJSONÊñá‰ª∂');
                        }
                    };

                    reader.readAsText(file);
                });
            }

            // Êõ¥Êñ∞ÂõæÂ±ÇÈù¢Êùø
            function updateLayersPanel() {
                // Êõ¥Êñ∞ËæπÁïåÂàóË°®
                const boundaryList = document.getElementById('boundary-layers-list');
                const boundaryCount = document.getElementById('boundary-count');
                boundaryList.innerHTML = '';
                boundaryCount.textContent = allBoundaries.length;

                allBoundaries.forEach((boundary, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    item.innerHTML = `
                        <div class="layer-item-info">
                            <div class="layer-item-name">${boundary.name}</div>
                            <div class="layer-item-date">${boundary.type}</div>
                        </div>
                        <div class="layer-item-actions">
                            <button class="layer-action-btn toggle ${boundary.visible ? '' : 'hidden'}" data-index="${index}">
                                ${boundary.visible ? 'üëÅ' : 'üëÅ‚Äçüó®'}
                            </button>
                            <button class="layer-action-btn" data-index="${index}">√ó</button>
                        </div>
                    `;

                    item.querySelector('.layer-item-info').addEventListener('click', () => {
                        if (boundary.layer) {
                            map.fitBounds(boundary.layer.getBounds());
                        }
                    });

                    item.querySelector('.toggle').addEventListener('click', (e) => {
                        e.stopPropagation();
                        boundary.visible = !boundary.visible;
                        
                        if (boundary.visible) {
                            const showCheckbox = document.getElementById('show-boundaries-checkbox');
                            if (showCheckbox && showCheckbox.checked) {
                                boundaryLayers.addLayer(boundary.layer);
                            }
                        } else {
                            boundaryLayers.removeLayer(boundary.layer);
                        }
                        
                        updateLayersPanel();
                    });

                    item.querySelectorAll('.layer-action-btn')[1].addEventListener('click', (e) => {
                        e.stopPropagation();
                        boundaryLayers.removeLayer(boundary.layer);
                        allBoundaries.splice(index, 1);
                        updateLayersPanel();
                    });

                    boundaryList.appendChild(item);
                });

                // Êõ¥Êñ∞‰∫ã‰ª∂ÂàóË°®
                const eventList = document.getElementById('event-layers-list');
                const eventCount = document.getElementById('event-count');
                eventList.innerHTML = '';
                eventCount.textContent = annotations.events.length;

                annotations.events.forEach((event, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    item.innerHTML = `
                        <div class="layer-item-info">
                            <div class="layer-item-name">${event.name}</div>
                            <div class="layer-item-date">${event.time} | ${event.location1} ${event.relation} ${event.location2}</div>
                        </div>
                        <div class="layer-item-actions">
                            <button class="layer-action-btn" data-index="${index}">√ó</button>
                        </div>
                    `;

                    item.querySelector('.layer-item-info').addEventListener('click', () => {
                        // ÂÆö‰ΩçÂà∞‰∫ã‰ª∂Âå∫Âüü
                        const bounds = L.latLngBounds([
                            L.latLng(event.loc1Coords.latitude, event.loc1Coords.longitude),
                            L.latLng(event.loc2Coords.latitude, event.loc2Coords.longitude)
                        ]);
                        map.fitBounds(bounds, { padding: [50, 50] });
                    });

                    item.querySelector('.layer-action-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteEvent(index);
                    });

                    eventList.appendChild(item);
                });

                // Êõ¥Êñ∞Ê†áËÆ∞ÂàóË°®
                const markerList = document.getElementById('marker-layers-list');
                const markerCount = document.getElementById('marker-count');
                markerList.innerHTML = '';
                const visibleMarkers = annotations.markers.filter(m => isSameDay(m.date, currentDate));
                markerCount.textContent = visibleMarkers.length;

                visibleMarkers.forEach((marker, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    item.innerHTML = `
                        <div class="layer-item-info">
                            <div class="layer-item-name">Ê†áËÆ∞ #${index + 1}</div>
                            <div class="layer-item-date">${formatDate(marker.date)}</div>
                        </div>
                        <div class="layer-item-actions">
                            <button class="layer-action-btn">√ó</button>
                        </div>
                    `;

                    item.querySelector('.layer-item-info').addEventListener('click', () => {
                        map.setView(marker.latlng, 12);
                    });

                    item.querySelector('.layer-action-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (marker.layer) map.removeLayer(marker.layer);
                        annotations.markers = annotations.markers.filter(m => m !== marker);
                        updateLayersPanel();
                    });

                    markerList.appendChild(item);
                });

                // Êõ¥Êñ∞Á∫øÊù°ÂàóË°®
                const lineList = document.getElementById('line-layers-list');
                const lineCount = document.getElementById('line-count');
                lineList.innerHTML = '';
                const visibleLines = [...annotations.lines, ...annotations.arrows].filter(l => isSameDay(l.date, currentDate));
                lineCount.textContent = visibleLines.length;

                visibleLines.forEach((line, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    const typeName = line.type === 'arrow' ? 'ÁÆ≠Â§¥' : line.type === 'chevron' ? 'Èõ™‰ΩõÈæô' : 'Á∫øÊù°';
                    item.innerHTML = `
                        <div class="layer-item-info">
                            <div class="layer-item-name">${typeName} #${index + 1}</div>
                            <div class="layer-item-date">${formatDate(line.date)}</div>
                        </div>
                        <div class="layer-item-actions">
                            <button class="layer-action-btn">√ó</button>
                        </div>
                    `;

                    item.querySelector('.layer-item-info').addEventListener('click', () => {
                        if (line.points && line.points.length > 0) {
                            map.setView(line.points[0], 12);
                        }
                    });

                    item.querySelector('.layer-action-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (line.layer) map.removeLayer(line.layer);
                        annotations.lines = annotations.lines.filter(l => l !== line);
                        annotations.arrows = annotations.arrows.filter(a => a !== line);
                        updateLayersPanel();
                    });

                    lineList.appendChild(item);
                });

                // Êõ¥Êñ∞ÊñáÊú¨Ê°ÜÂàóË°®
                const textList = document.getElementById('text-layers-list');
                const textCount = document.getElementById('text-count');
                textList.innerHTML = '';
                const visibleTexts = annotations.textBoxes.filter(t => isSameDay(t.date, currentDate));
                textCount.textContent = visibleTexts.length;

                visibleTexts.forEach((textBox, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    item.innerHTML = `
                        <div class="layer-item-info">
                            <div class="layer-item-name">ÊñáÊú¨ #${index + 1}</div>
                            <div class="layer-item-date">${formatDate(textBox.date)}</div>
                        </div>
                        <div class="layer-item-actions">
                            <button class="layer-action-btn">√ó</button>
                        </div>
                    `;

                    item.querySelector('.layer-item-info').addEventListener('click', () => {
                        map.setView(textBox.latlng, 12);
                    });

                    item.querySelector('.layer-action-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (textBox.cleanup) textBox.cleanup();
                        if (textBox.element) textBox.element.remove();
                        annotations.textBoxes = annotations.textBoxes.filter(t => t !== textBox);
                        updateLayersPanel();
                    });

                    textList.appendChild(item);
                });
            }

            function formatDate(date) {
                const d = new Date(date);
                return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
            }

            // ÂõæÂ±ÇÈù¢ÊùøÊäòÂè†ÂäüËÉΩ
            document.getElementById('toggle-layers').addEventListener('click', function() {
                const content = document.querySelector('.layers-content');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    this.textContent = '‚ñº';
                } else {
                    content.style.display = 'none';
                    this.textContent = '‚ñ∂';
                }
            });

            function initDatabaseLoader() {
                const loadDbBtn = document.getElementById('load-db-btn');
                const dbFileInput = document.getElementById('db-file-input');

                loadDbBtn.addEventListener('click', () => {
                    dbFileInput.click();
                });

                dbFileInput.addEventListener('change', function(e) {
                    const files = e.target.files;
                    if (!files || files.length === 0) return;

                    showDbStatus(`Ê≠£Âú®Âä†ËΩΩ ${files.length} ‰∏™Êñá‰ª∂...`);
                    
                    let filesProcessed = 0;
                    let locationDbLoaded = false;
                    let geoJsonLoaded = 0;
                    
                    Array.from(files).forEach(file => {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            try {
                                const jsonData = JSON.parse(event.target.result);
                                
                                // Âà§Êñ≠Êñá‰ª∂Á±ªÂûã
                                if (isLocationDatabase(jsonData)) {
                                    // ËøôÊòØÂú∞ÁÇπÊï∞ÊçÆÂ∫ìÊñá‰ª∂
                                    const rawDatabase = jsonData;
                                    
                                    // Êü•ÊâæÂπ∂ÁßªÈô§Taiwan
                                    const taiwanIndex = rawDatabase.findIndex(country => {
                                        const name = country.name.toLowerCase();
                                        return name === 'taiwan' || 
                                               name === 'taiwan, province of china' ||
                                               name.includes('taiwan');
                                    });
                                    
                                    let taiwanData = null;
                                    if (taiwanIndex !== -1) {
                                        taiwanData = rawDatabase[taiwanIndex];
                                        rawDatabase.splice(taiwanIndex, 1);
                                    }
                                    
                                    // Â∞ÜÂè∞ÊπæÊ∑ªÂä†Âà∞‰∏≠ÂõΩÁöÑÁúÅ‰ªΩ‰∏≠
                                    const chinaIndex = rawDatabase.findIndex(country => {
                                        const name = country.name.toLowerCase();
                                        return name === 'china' || name === '‰∏≠ÂõΩ';
                                    });
                                    
                                    if (chinaIndex !== -1 && taiwanData) {
                                        if (!rawDatabase[chinaIndex].states) {
                                            rawDatabase[chinaIndex].states = [];
                                        }
                                        
                                        const taiwanProvince = {
                                            id: taiwanData.id || 'taiwan_province',
                                            name: 'Âè∞ÊπæÁúÅ',
                                            latitude: taiwanData.latitude || '23.5',
                                            longitude: taiwanData.longitude || '121',
                                            cities: taiwanData.states?.[0]?.cities || []
                                        };
                                        
                                        rawDatabase[chinaIndex].states.push(taiwanProvince);
                                    }
                                    
                                    geoDatabase = rawDatabase;
                                    databaseLoaded = true;
                                    locationDbLoaded = true;
                                    
                                    console.log(`Âú∞ÁÇπÊï∞ÊçÆÂ∫ìÂä†ËΩΩÊàêÂäü: ${file.name}`);
                                } else if (isGeoJSON(jsonData)) {
                                    // ËøôÊòØGeoJSONËæπÁïåÊñá‰ª∂
                                    const fileName = file.name.replace('.json', '').replace('.geojson', '');
                                    localGeoJSONFiles[fileName] = jsonData;
                                    geoJsonLoaded++;
                                    
                                    console.log(`GeoJSONËæπÁïåÊñá‰ª∂Âä†ËΩΩÊàêÂäü: ${file.name}`);
                                } else {
                                    console.warn(`Êó†Ê≥ïËØÜÂà´Êñá‰ª∂Á±ªÂûã: ${file.name}`);
                                }
                                
                                filesProcessed++;
                                
                                // ÊâÄÊúâÊñá‰ª∂Â§ÑÁêÜÂÆåÊØï
                                if (filesProcessed === files.length) {
                                    let statusMsg = '';
                                    
                                    if (locationDbLoaded) {
                                        const totalCountries = geoDatabase.length;
                                        const totalStates = geoDatabase.reduce((sum, c) => sum + (c.states?.length || 0), 0);
                                        const totalCities = geoDatabase.reduce((sum, c) => 
                                            sum + (c.states?.reduce((s, st) => s + (st.cities?.length || 0), 0) || 0), 0
                                        );
                                        statusMsg = `‚úì Âú∞ÁÇπÂ∫ì: ${totalCountries}ÂõΩ, ${totalStates}ÁúÅ, ${totalCities}Â∏Ç`;
                                    }
                                    
                                    if (geoJsonLoaded > 0) {
                                        statusMsg += ` | ${geoJsonLoaded}‰∏™ËæπÁïåÊñá‰ª∂`;
                                    }
                                    
                                    showDbStatus(statusMsg || '‚úì Êñá‰ª∂Âä†ËΩΩÂÆåÊàê');
                                    
                                    if (databaseLoaded) {
                                        document.getElementById('country-select').disabled = false;
                                        document.getElementById('search-address-btn').disabled = false;
                                        populateCountries();
                                    }
                                }
                                
                            } catch (error) {
                                console.error(`Ëß£ÊûêÊñá‰ª∂Â§±Ë¥• ${file.name}:`, error);
                                filesProcessed++;
                                
                                if (filesProcessed === files.length) {
                                    showDbStatus('ÈÉ®ÂàÜÊñá‰ª∂Âä†ËΩΩÂ§±Ë¥•', true);
                                }
                            }
                        };
                        
                        reader.onerror = function() {
                            console.error(`ËØªÂèñÊñá‰ª∂Â§±Ë¥•: ${file.name}`);
                            filesProcessed++;
                            
                            if (filesProcessed === files.length) {
                                showDbStatus('ÈÉ®ÂàÜÊñá‰ª∂ËØªÂèñÂ§±Ë¥•', true);
                            }
                        };
                        
                        reader.readAsText(file);
                    });
                });
            }
            
            // Âà§Êñ≠ÊòØÂê¶ÊòØÂú∞ÁÇπÊï∞ÊçÆÂ∫ì
            function isLocationDatabase(data) {
                if (!Array.isArray(data)) return false;
                if (data.length === 0) return false;
                
                const sample = data[0];
                return sample.hasOwnProperty('name') && 
                       sample.hasOwnProperty('id') && 
                       (sample.hasOwnProperty('latitude') || sample.hasOwnProperty('states'));
            }
            
            // Âà§Êñ≠ÊòØÂê¶ÊòØGeoJSON
            function isGeoJSON(data) {
                if (!data) return false;
                
                return data.type === 'FeatureCollection' || 
                       data.type === 'Feature' || 
                       data.type === 'GeometryCollection' ||
                       (data.type && ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 
                                      'Polygon', 'MultiPolygon'].includes(data.type));
            }

            function initLocationSearch() {
                const countrySelect = document.getElementById('country-select');
                const stateSelect = document.getElementById('state-select');
                const citySelect = document.getElementById('city-select');
                const goLocationBtn = document.getElementById('go-location-btn');
                const searchInput = document.getElementById('address-search-input');
                const searchBtn = document.getElementById('search-address-btn');
                const searchResults = document.getElementById('search-results');
                const resultsList = document.getElementById('results-list');

                if (!countrySelect || !stateSelect || !citySelect) {
                    console.error('‰∏ãÊãâËèúÂçïÂÖÉÁ¥†Êú™ÊâæÂà∞');
                    return;
                }

                let selectedCountry = null;
                let selectedState = null;
                let selectedCity = null;

                initDatabaseLoader();

                window.populateCountries = function() {
                    countrySelect.innerHTML = '<option value="">ËØ∑ÈÄâÊã©ÂõΩÂÆ∂</option>';
                    geoDatabase.sort((a, b) => a.name.localeCompare(b.name)).forEach(country => {
                        const option = document.createElement('option');
                        option.value = country.id;
                        option.textContent = country.name;
                        countrySelect.appendChild(option);
                    });
                };

                countrySelect.addEventListener('change', function() {
                    stateSelect.innerHTML = '<option value="">ËØ∑ÈÄâÊã©Â∑û/ÁúÅ</option>';
                    citySelect.innerHTML = '<option value="">ËØ∑ÂÖàÈÄâÊã©Â∑û/ÁúÅ</option>';
                    stateSelect.disabled = true;
                    citySelect.disabled = true;
                    goLocationBtn.disabled = true;
                    selectedState = null;
                    selectedCity = null;

                    if (!this.value) {
                        selectedCountry = null;
                        return;
                    }

                    selectedCountry = geoDatabase.find(c => c.id == this.value);
                    
                    goLocationBtn.disabled = false;
                    
                    if (selectedCountry && selectedCountry.states && selectedCountry.states.length > 0) {
                        selectedCountry.states.sort((a, b) => a.name.localeCompare(b.name)).forEach(state => {
                            const option = document.createElement('option');
                            option.value = state.id;
                            option.textContent = state.name;
                            stateSelect.appendChild(option);
                        });
                        stateSelect.disabled = false;
                    }
                });

                stateSelect.addEventListener('change', function() {
                    citySelect.innerHTML = '<option value="">ËØ∑ÈÄâÊã©ÂüéÂ∏Ç</option>';
                    citySelect.disabled = true;
                    selectedCity = null;

                    if (!this.value || !selectedCountry) {
                        selectedState = null;
                        goLocationBtn.disabled = false;
                        return;
                    }

                    selectedState = selectedCountry.states.find(s => s.id == this.value);
                    
                    goLocationBtn.disabled = false;
                    
                    if (selectedState && selectedState.cities && selectedState.cities.length > 0) {
                        selectedState.cities.sort((a, b) => a.name.localeCompare(b.name)).forEach(city => {
                            const option = document.createElement('option');
                            option.value = city.id;
                            option.textContent = city.name;
                            citySelect.appendChild(option);
                        });
                        citySelect.disabled = false;
                    }
                });

                citySelect.addEventListener('change', function() {
                    if (!this.value || !selectedState) {
                        selectedCity = null;
                        goLocationBtn.disabled = false;
                        return;
                    }

                    selectedCity = selectedState.cities.find(c => c.id == this.value);
                    goLocationBtn.disabled = false;
                });

                goLocationBtn.addEventListener('click', async function() {
                    let lat, lon, zoom, locationName, locationType;

                    if (selectedCity) {
                        lat = parseFloat(selectedCity.latitude);
                        lon = parseFloat(selectedCity.longitude);
                        zoom = 11;
                        locationName = selectedCity.name;
                        locationType = 'city';
                    } else if (selectedState) {
                        lat = parseFloat(selectedState.latitude);
                        lon = parseFloat(selectedState.longitude);
                        zoom = 7;
                        locationName = selectedState.name;
                        locationType = 'state';
                    } else if (selectedCountry) {
                        lat = parseFloat(selectedCountry.latitude);
                        lon = parseFloat(selectedCountry.longitude);
                        zoom = 5;
                        locationName = selectedCountry.name;
                        locationType = 'country';
                    }

                    if (!isNaN(lat) && !isNaN(lon)) {
                        map.setView([lat, lon], zoom);
                        showSearchStatus(`Â∑≤ÂÆö‰ΩçÂà∞: ${locationName}`);
                        
                        // Ê£ÄÊü•ÊòØÂê¶ÊòØ‰∏≠ÂõΩÁõ∏ÂÖ≥
                        const isChinaRelated = selectedCountry && 
                            (selectedCountry.name.toLowerCase().includes('china') || 
                             selectedCountry.name.includes('‰∏≠ÂõΩ'));

                        if (isChinaRelated) {
                            // ‰∏≠ÂõΩÁõ∏ÂÖ≥Ôºå‰ΩøÁî®Êú¨Âú∞GeoJSON
                            await fetchBoundaryFromNominatim({
                                name: locationName,
                                displayName: locationName,
                                type: locationType,
                                country: 'China',
                                parentCountry: 'China'
                            });
                        } else {
                            // ÂÖ∂‰ªñÂõΩÂÆ∂‰ΩøÁî®API
                            await fetchBoundaryFromNominatim({
                                name: locationName,
                                displayName: locationName,
                                type: locationType
                            });
                        }
                        
                        setTimeout(() => {
                            document.getElementById('location-panel').style.display = 'none';
                        }, 1000);
                    } else {
                        showSearchStatus('ËØ•‰ΩçÁΩÆÁº∫Â∞ëÂùêÊ†á‰ø°ÊÅØ', true);
                    }
                });

                function searchAddress(query) {
                    if (!databaseLoaded) {
                        showSearchStatus('ËØ∑ÂÖàÂä†ËΩΩÊï∞ÊçÆÂ∫ì', true);
                        return;
                    }

                    showSearchStatus('Ê≠£Âú®ÊêúÁ¥¢...');
                    searchBtn.disabled = true;

                    setTimeout(() => {
                        const searchTerm = query.toLowerCase();
                        const results = [];

                        geoDatabase.forEach(country => {
                            const countryMatch = country.name.toLowerCase().includes(searchTerm);
                           
                            if (countryMatch) {
                                results.push({
                                    type: 'country',
                                    name: country.name,
                                    latitude: country.latitude,
                                    longitude: country.longitude,
                                    displayName: country.name,
                                    zoom: 5
                                });
                            }

                            country.states?.forEach(state => {
                                const stateMatch = state.name.toLowerCase().includes(searchTerm);
                                
                                if (stateMatch) {
                                    results.push({
                                        type: 'state',
                                        name: state.name,
                                        latitude: state.latitude,
                                        longitude: state.longitude,
                                        displayName: `${state.name} - ${country.name}`,
                                        zoom: 7
                                    });
                                }

                                state.cities?.forEach(city => {
                                    if (city.name.toLowerCase().includes(searchTerm)) {
                                        results.push({
                                            type: 'city',
                                            name: city.name,
                                            latitude: city.latitude,
                                            longitude: city.longitude,
                                            displayName: `${city.name} - ${state.name}, ${country.name}`,
                                            zoom: 11
                                        });
                                    }
                                });
                            });
                        });

                        if (results.length === 0) {
                            showSearchStatus('Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÂú∞ÂùÄ', true);
                            searchResults.style.display = 'none';
                            searchBtn.disabled = false;
                            return;
                        }

                        const sortedResults = results.sort((a, b) => {
                            const order = { city: 1, state: 2, country: 3 };
                            return order[a.type] - order[b.type];
                        }).slice(0, 20);

                        displayResults(sortedResults);
                        showSearchStatus(`ÊâæÂà∞ ${sortedResults.length} ‰∏™ÁªìÊûú`);
                        searchBtn.disabled = false;
                    }, 100);
                }

                function displayResults(results) {
                    resultsList.innerHTML = '';
                    
                    results.forEach((location) => {
                        const resultItem = document.createElement('div');
                        resultItem.className = 'result-item';
                        
                        const typeText = location.type === 'country' ? 'ÂõΩÂÆ∂' : 
                                        location.type === 'state' ? 'Â∑û/ÁúÅ' : 'ÂüéÂ∏Ç';
                        
                        resultItem.innerHTML = `
                            <div style="font-weight: bold; margin-bottom: 3px;">${location.displayName}</div>
                            <div style="font-size: 11px; color: #666;">${typeText}</div>
                        `;
                        
                        resultItem.addEventListener('click', async () => {
                            const lat = parseFloat(location.latitude);
                            const lon = parseFloat(location.longitude);
                            
                            if (isNaN(lat) || isNaN(lon)) {
                                showSearchStatus('ËØ•‰ΩçÁΩÆÁº∫Â∞ëÂùêÊ†á‰ø°ÊÅØ', true);
                                return;
                            }
                            
                            map.setView([lat, lon], location.zoom);
                            
                            showSearchStatus(`Â∑≤ÂÆö‰ΩçÂà∞: ${location.displayName}`);
                            searchResults.style.display = 'none';
                            
                            // Ê£ÄÊü•ÊòØÂê¶ÊòØ‰∏≠ÂõΩÁõ∏ÂÖ≥
                            const isChinaRelated = location.displayName.includes('‰∏≠ÂõΩ') || 
                                                  location.displayName.includes('China');

                            if (isChinaRelated) {
                                // ‰∏≠ÂõΩÁõ∏ÂÖ≥Ôºå‰ΩøÁî®Êú¨Âú∞GeoJSON
                                await fetchBoundaryFromNominatim({
                                    name: location.name,
                                    displayName: location.name,
                                    type: location.type,
                                    country: 'China',
                                    parentCountry: 'China'
                                });
                            } else {
                                // ÂÖ∂‰ªñÂõΩÂÆ∂‰ΩøÁî®API
                                await fetchBoundaryFromNominatim({
                                    name: location.displayName,
                                    displayName: location.displayName,
                                    type: location.type
                                });
                            }
                            
                            setTimeout(() => {
                                document.getElementById('location-panel').style.display = 'none';
                            }, 1000);
                        });
                        
                        resultsList.appendChild(resultItem);
                    });
                    
                    searchResults.style.display = 'block';
                }

                searchBtn.addEventListener('click', () => {
                    const query = searchInput.value.trim();
                    if (!query) {
                        showSearchStatus('ËØ∑ËæìÂÖ•ÊêúÁ¥¢ÂÜÖÂÆπ', true);
                        return;
                    }
                    searchAddress(query);
                });

                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        searchBtn.click();
                    }
                });

                searchInput.addEventListener('input', () => {
                    if (searchInput.value.trim() === '') {
                        searchResults.style.display = 'none';
                        showSearchStatus('');
                    }
                });
            }

            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '255, 255, 255';
            }
            
            function getSplinePoints(points, tension = 0.5, resolution = 16) {
                if (points.length < 2) return points;
                let pts = points;
                let splinePoints = [pts[0]]; 
                for (let i = 0; i < pts.length - 1; i++) {
                    const p0 = (i === 0) ? pts[i] : pts[i - 1];
                    const p1 = pts[i];
                    const p2 = pts[i + 1];
                    const p3 = (i === pts.length - 2) ? pts[i + 1] : pts[i + 2];
                    for (let t = 1; t <= resolution; t++) { 
                        const step = t / resolution;
                        const t2 = step * step;
                        const t3 = t2 * step;
                        const h1 = 2 * t3 - 3 * t2 + 1;
                        const h2 = -2 * t3 + 3 * t2;
                        const h3 = t3 - 2 * t2 + step;
                        const h4 = t3 - t2;
                        const m1_lat = (p2.lat - p0.lat) * tension;
                        const m2_lat = (p3.lat - p1.lat) * tension;
                        const m1_lng = (p2.lng - p0.lng) * tension;
                        const m2_lng = (p3.lng - p1.lng) * tension;
                        const lat = h1 * p1.lat + h2 * p2.lat + h3 * m1_lat + h4 * m2_lat;
                        const lng = h1 * p1.lng + h2 * p2.lng + h3 * m1_lng + h4 * m2_lng;
                        splinePoints.push(L.latLng(lat, lng));
                    }
                }
                return splinePoints;
            }
            
            const themeSettings = {
                buttonColor: '#666666', 
                fillColor: '#ffffff',
                fillOpacity: 0.5
            };
            
            function applyTheme() {
                const buttonRgb = hexToRgb(themeSettings.buttonColor);
                document.querySelectorAll('.btn, .calendar-header button').forEach(el => {
                    el.style.background = themeSettings.buttonColor;
                });
                document.querySelectorAll('.tool-icon.active, .file-icon.active').forEach(el => {
                    el.style.background = `rgba(${buttonRgb}, 0.5)`;
                });
                document.querySelectorAll('#tool-panel, #date-selector, #location-panel, #file-controls, #zoom-control').forEach(el => {
                    el.style.background = `rgba(${hexToRgb(themeSettings.fillColor)}, ${themeSettings.fillOpacity})`;
                });
                const dateDisplay = document.getElementById('date-display');
                if (dateDisplay) {
                    dateDisplay.style.color = themeSettings.buttonColor; 
                }
                const track = document.getElementById('zoom-slider-track');
                const thumb = document.getElementById('zoom-slider-thumb');
                if (track) track.style.background = themeSettings.buttonColor;
                if (thumb) thumb.style.borderColor = themeSettings.buttonColor;
                document.querySelectorAll('.zoom-level-mark.current').forEach(mark => {
                    mark.style.color = themeSettings.buttonColor;
                });
            }

            function initYearSelect() {
                yearSelect.innerHTML = '';
                for (let y = -2500; y <= 2100; y++) {
                    const option = document.createElement('option');
                    option.value = y;
                    option.textContent = y > 0 ? y + 'Âπ¥' : 'ÂÖ¨ÂÖÉÂâç' + Math.abs(y) + 'Âπ¥';
                    yearSelect.appendChild(option);
                }
            }

            function renderCalendar() {
                const year = calendarDate.getFullYear();
                const month = calendarDate.getMonth();
                yearSelect.value = year;
                monthSelect.value = month;
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const prevLastDay = new Date(year, month, 0);
                const firstDayWeek = firstDay.getDay();
                const lastDate = lastDay.getDate();
                const prevLastDate = prevLastDay.getDate();
                let html = '';
                for (let i = firstDayWeek - 1; i >= 0; i--) {
                    const day = prevLastDate - i;
                    html += `<div class="calendar-day other-month" data-date="${year}-${month}-${day}">${day}</div>`;
                }
                for (let day = 1; day <= lastDate; day++) {
                    const dateStr = `${year}-${month + 1}-${day}`;
                    const isSelected = currentDate.getFullYear() === year && 
                                      currentDate.getMonth() === month && 
                                      currentDate.getDate() === day;
                    const isToday = new Date().getFullYear() === year && 
                                   new Date().getMonth() === month && 
                                   new Date().getDate() === day;
                    let classes = 'calendar-day';
                    if (isSelected) classes += ' selected';
                    if (isToday) classes += ' today';
                    html += `<div class="${classes}" data-date="${dateStr}">${day}</div>`;
                }
                const remainingDays = 42 - (firstDayWeek + lastDate);
                for (let day = 1; day <= remainingDays; day++) {
                    html += `<div class="calendar-day other-month" data-date="${year}-${month + 2}-${day}"></div>`;
                }
                calendarDays.innerHTML = html;
                calendarDays.querySelectorAll('.calendar-day:not(.other-month)').forEach(dayEl => {
                    dayEl.addEventListener('click', function() {
                        const [y, m, d] = this.dataset.date.split('-').map(Number);
                        currentDate = new Date(y, m - 1, d);
                        updateDateDisplay();
                        renderCalendar();
                        calendarContainer.classList.remove('show');
                    });
                });
            }

            dateDisplayEl.addEventListener('click', function(e) {
                e.stopPropagation();
                calendarContainer.classList.toggle('show');
                if (calendarContainer.classList.contains('show')) {
                    calendarDate = new Date(currentDate);
                    renderCalendar();
                }
            });

            document.addEventListener('click', function(e) {
                if (!calendarContainer.contains(e.target) && e.target !== dateDisplayEl) {
                    calendarContainer.classList.remove('show');
                }
            });

            prevMonthBtn.addEventListener('click', function() {
                calendarDate.setMonth(calendarDate.getMonth() - 1);
                renderCalendar();
            });

            nextMonthBtn.addEventListener('click', function() {
                calendarDate.setMonth(calendarDate.getMonth() + 1);
                renderCalendar();
            });

            yearSelect.addEventListener('change', function() {
                calendarDate.setFullYear(parseInt(this.value));
                renderCalendar();
            });

            monthSelect.addEventListener('change', function() {
                calendarDate.setMonth(parseInt(this.value));
                renderCalendar();
            });

            function updateDateDisplay() {
                const y = currentDate.getFullYear();
                const m = String(currentDate.getMonth() + 1).padStart(2, '0');
                const d = String(currentDate.getDate()).padStart(2, '0');
                dateDisplayEl.textContent = `ÂΩìÂâçÊó•Êúü: ${y}-${m}-${d}`;
                clearDrawingState();
                updateVisibleAnnotations();
            }

            function showHint(text) {
                const hint = document.getElementById('hint');
                if (text) {
                    hint.textContent = text;
                    hint.style.display = 'block';
                } else {
                    hint.style.display = 'none';
                }
            }

            function updateMapCursor() {
                const mapEl = document.getElementById('map');
                mapEl.className = '';
                if (currentTool === 'pan') {
                    mapEl.classList.add('pan-mode');
                    map.doubleClickZoom.enable();
                } else if (currentTool === 'eraser') {
                    mapEl.classList.add('eraser-mode');
                    map.doubleClickZoom.disable();
                } else {
                    map.doubleClickZoom.disable();
                }
            }

            function isSameDay(date1, date2) {
                if (!date1 || !date2) return false;
                return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
            }

            function updateVisibleAnnotations() {
                const currentZoom = map.getZoom();
                [...annotations.markers, ...annotations.lines, ...annotations.arrows].forEach(a => {
                    if (a.layer) map.removeLayer(a.layer);
                });
                annotations.textBoxes.forEach(t => {
                    if (t.element) t.element.style.display = 'none';
                });
                const allAnnotations = [
                    ...annotations.markers,
                    ...annotations.lines,
                    ...annotations.arrows,
                    ...annotations.textBoxes
                ];
                allAnnotations.forEach(a => {
                    const isSameDate = isSameDay(a.date, currentDate);
                    const createdZoom = a.zoomLevel || 18;
                    const zoomDiff = currentZoom - createdZoom;
                    
                    let opacity = 1.0;
                    let shouldShow = true;
                    
                    if (zoomDiff <= 0) {
                        opacity = 1.0;
                    } else if (zoomDiff >= 4) {
                        shouldShow = false;
                    } else {
                        opacity = 1.0 - (zoomDiff * 0.25);
                    }
                    
                    const isVisible = isSameDate && shouldShow;
                    
                    if (isVisible) {
                        if (a.layer) {
                            if (!map.hasLayer(a.layer)) map.addLayer(a.layer);
                            
                            if (a.type === 'marker') {
                                const icon = a.layer.getElement();
                                if (icon) {
                                    icon.style.opacity = opacity;
                                }
                            } else if (a.type === 'line') {
                                a.layer.setStyle({ opacity: opacity * (a.options.opacity || 1) });
                            } else if (a.type === 'arrow' || a.type === 'chevron') {
                                a.layer.eachLayer(subLayer => {
                                    if (subLayer.setStyle) {
                                        subLayer.setStyle({ opacity: opacity * (a.options.opacity || 1), fillOpacity: opacity * (a.options.opacity || 1) });
                                    }
                                    if (subLayer.getElement) {
                                        const elem = subLayer.getElement();
                                        if (elem) elem.style.opacity = opacity;
                                    }
                                });
                            }
                        } else if (a.element) {
                            a.element.style.display = 'block';
                            a.element.style.opacity = opacity * (a.options.opacity || 1);
                        }
                    }
                });
                
                updateLayersPanel();
            }

            function clearDrawingState() {
                if (drawingState.tempMarker) {
                    map.removeLayer(drawingState.tempMarker);
                    drawingState.tempMarker = null;
                }
                if (drawingState.previewLayer) {
                    map.removeLayer(drawingState.previewLayer);
                    drawingState.previewLayer = null;
                }
                drawingState.dashedSegments.forEach(seg => map.removeLayer(seg));
                drawingState.dashedSegments = [];
                drawingState.isDrawing = false;
                drawingState.startPoint = null;
                drawingState.points = [];
            }

            function updateToolOptions() {
                document.querySelectorAll('.tool-options-popup').forEach(p => p.remove());
                if (!['annotate', 'text'].includes(currentTool)) return;
                const activeIcon = document.querySelector(`[data-tool="${currentTool}"]`);
                if (!activeIcon) return;
                let html = '';
                let helpText = '';
                if (currentTool === 'annotate') {
                    const opts = toolOptions.annotate;
                    html = `<div class="help-icon" data-hint="${helpText}">?</div>
                    <div class="option-group" style="grid-column: 1 / -1;"><label>Ê†áËÆ∞Ê†∑Âºè (ÂçïÂáª):</label><select id="annotate-marker-type">
                        <option value="pin">Â§ßÂ§¥Èíà</option>
                        <option value="pushpin">ÂõæÈíâ</option>
                        <option value="dot">ÂúÜÁÇπ</option>
                        <option value="none">Êó†Ê†áËÆ∞</option> 
                    </select></div>
                    <div class="option-group" style="grid-column: 1 / -1;"><label>Á∫øÊù°Ê†∑Âºè:</label><select id="annotate-line-style">
                        <option value="solid">ÂÆûÁ∫ø</option>
                        <option value="dashed">ËôöÁ∫ø</option>
                        <option value="arrow">ÁÆ≠Â§¥</option>
                        <option value="chevron">Èõ™‰ΩõÈæôÁÆ≠Â§¥</option>
                    </select></div>
                    <div class="option-group" style="grid-column: 1 / -1;"><label>Á∫øÊù°Á±ªÂûã:</label><select id="annotate-line-type">
                        <option value="straight">Áõ¥Á∫ø</option>
                        <option value="bezier">Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø</option>
                    </select></div>
                    <div class="option-group"><label>È¢úËâ≤:</label><div class="color-picker"><input type="color" id="annotate-color" value="${opts.color}"></div></div>
                    <div class="option-group"><label>Á≤óÁªÜ:</label><input type="number" id="annotate-weight" value="${opts.weight}" min="1" max="10"></div>
                    <div class="option-group" style="grid-column: 1 / -1;"><label>‰∏çÈÄèÊòéÂ∫¶: <span id="line-opacity-display">${Math.round(opts.opacity * 100)}%</span></label><input type="range" id="annotate-opacity" value="${opts.opacity}" min="0" max="1" step="0.1"></div>
                    <div class="option-group" style="grid-column: 1 / -1; display: ${opts.lineStyle === 'arrow' ? 'block' : 'none'};" id="arrow-text-group"><label>ÁÆ≠Â§¥ÊñáÂ≠ó:</label><input type="text" id="annotate-arrow-text" value="${opts.arrowText}" placeholder="ËØ¥Êòé (ÂèØÈÄâ)"></div>`;
                } else if (currentTool === 'text') {
                    const opts = toolOptions.text;
                    html = `<div class="help-icon" data-hint="${helpText}">?</div>
                    <div class="option-group"><label>ËÉåÊôØ:</label><div class="color-picker"><input type="color" id="text-bg-color" value="${opts.bgColor}"></div></div>
                    <div class="option-group"><label>ÊñáÂ≠ó:</label><div class="color-picker"><input type="color" id="text-color" value="${opts.textColor}"></div></div>
                    <div class="option-group" style="grid-column: 1 / -1;"><label>ÈÄèÊòéÂ∫¶: <span id="opacity-display">${Math.round(opts.opacity * 100)}%</span></label><input type="range" id="text-opacity" value="${opts.opacity}" min="0" max="1" step="0.1"></div>`;
                }
                const popup = document.createElement('div');
                popup.className = 'tool-options-popup show';
                popup.innerHTML = html;
                popup.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
                activeIcon.appendChild(popup);
                attachOptionListeners();
            }

            function attachOptionListeners() {
                const markerTypeEl = document.getElementById('annotate-marker-type');
                const lineStyleEl = document.getElementById('annotate-line-style');
                const lineTypeEl = document.getElementById('annotate-line-type');
                const colorEl = document.getElementById('annotate-color');
                const weightEl = document.getElementById('annotate-weight');
                const opacityEl = document.getElementById('annotate-opacity');
                const arrowTextEl = document.getElementById('annotate-arrow-text');
                const arrowTextGroup = document.getElementById('arrow-text-group');
                if (markerTypeEl) markerTypeEl.value = toolOptions.annotate.markerType;
                if (lineStyleEl) lineStyleEl.value = toolOptions.annotate.lineStyle;
                if (lineTypeEl) lineTypeEl.value = toolOptions.annotate.lineType;
                if (markerTypeEl) markerTypeEl.onchange = e => toolOptions.annotate.markerType = e.target.value;
                if (lineStyleEl) lineStyleEl.onchange = e => {
                    toolOptions.annotate.lineStyle = e.target.value;
                    if (arrowTextGroup) {
                        arrowTextGroup.style.display = e.target.value === 'arrow' ? 'block' : 'none';
                    }
                };
                if (lineTypeEl) lineTypeEl.onchange = e => toolOptions.annotate.lineType = e.target.value;
                if (colorEl) colorEl.onchange = e => toolOptions.annotate.color = e.target.value;
                if (weightEl) weightEl.onchange = e => toolOptions.annotate.weight = parseInt(e.target.value);
                if (opacityEl) opacityEl.oninput = e => {
                    toolOptions.annotate.opacity = parseFloat(e.target.value);
                    const display = document.getElementById('line-opacity-display');
                    if (display) display.textContent = Math.round(toolOptions.annotate.opacity * 100) + '%';
                };
                if (arrowTextEl) arrowTextEl.oninput = e => toolOptions.annotate.arrowText = e.target.value;
                const textBgColor = document.getElementById('text-bg-color');
                const textColor = document.getElementById('text-color');
                const textOpacity = document.getElementById('text-opacity');
                if (textBgColor) textBgColor.onchange = e => toolOptions.text.bgColor = e.target.value;
                if (textColor) textColor.onchange = e => toolOptions.text.textColor = e.target.value;
                if (textOpacity) textOpacity.oninput = e => {
                    toolOptions.text.opacity = parseFloat(e.target.value);
                    document.getElementById('opacity-display').textContent = Math.round(toolOptions.text.opacity * 100) + '%';
                };
            }

            document.querySelectorAll('.tool-icon').forEach(icon => {
                icon.onclick = function() {
                    const tool = this.dataset.tool;
                    if (!tool) return;
                    if (tool === 'clear') {
                        clearDrawingState();
                        if(confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÊ†áÊ≥®Âêó?')) {
                            annotations.markers.forEach(m => m.layer && map.removeLayer(m.layer));
                            annotations.lines.forEach(l => l.layer && map.removeLayer(l.layer));
                            annotations.arrows.forEach(a => a.layer && map.removeLayer(a.layer));
                            annotations.textBoxes.forEach(t => {
                                if (t.cleanup) t.cleanup();
                                if (t.element) t.element.remove();
                            });
                            annotations.markers = [];
                            annotations.lines = [];
                            annotations.arrows = [];
                            annotations.textBoxes = [];
                            updateLayersPanel();
                        }
                        return;
                    }
                    if (tool === 'location') {
                        const panel = document.getElementById('location-panel');
                        if (panel.style.display === 'block') {
                            panel.style.display = 'none';
                        } else {
                            panel.style.display = 'block';
                        }
                        document.querySelectorAll('.tool-options-popup').forEach(p => p.remove());
                        return;
                    }
                    if (currentTool === tool && tool !== 'pan') {
                        document.querySelectorAll('.tool-icon').forEach(i => {
                            i.classList.remove('active');
                            i.style.background = '';
                        });
                        const panIcon = document.querySelector('[data-tool="pan"]');
                        panIcon.classList.add('active');
                        panIcon.style.background = `rgba(${hexToRgb(themeSettings.buttonColor)}, 0.5)`;
                        currentTool = 'pan';
                        clearDrawingState();
                        document.querySelectorAll('.tool-options-popup').forEach(p => p.remove());
                        updateMapCursor();
                        map.dragging.enable();
                        return;
                    }
                    document.querySelectorAll('.tool-icon').forEach(i => {
                        i.classList.remove('active');
                        i.style.background = '';
                    });
                    this.classList.add('active');
                    currentTool = tool;
                    clearDrawingState();
                    updateToolOptions();
                    updateMapCursor();
                    if (tool === 'pan') {
                        map.dragging.enable();
                        showHint('');
                    } else if (tool === 'eraser') {
                        map.dragging.disable();
                    } else {
                        map.dragging.disable();
                    }
                };
            });

            function getMarkerSvg(type, color) {
                if (type === 'pin') {
                    return `<svg width="24" height="24" viewBox="0 0 24 24" fill="${color}" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0118 0z"/><circle cx="12" cy="10" r="3"/>
                    </svg>`;
                } else if (type === 'pushpin') {
                    return `<svg width="24" height="24" viewBox="0 0 24 24" fill="${color}" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 21v-4m-6-6h12M17 10l-5-5-5 5-2-2 7-7 7 7-2 2z"/>
                    </svg>`;
                } else if (type === 'dot') {
                    return '';
                }
                return '';
            }

            function createMarker(latlng, options) {
                const type = options.markerType;
                const color = options.color;
                if (type === 'dot') {
                    const icon = L.divIcon({
                        className: 'custom-marker dot-icon',
                        html: '',
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    });
                    const marker = L.marker(latlng, { icon: icon });
                    marker.getElement = () => marker._icon;
                    marker.on('add', function() {
                         this._icon.style.background = color;
                         this._icon.style.borderColor = 'white';
                    });
                    return marker;
                }
                const icon = L.divIcon({
                    className: `custom-marker ${type}-icon`,
                    html: getMarkerSvg(type, color),
                    iconSize: [24, 24],
                    iconAnchor: [12, 24]
                });
                return L.marker(latlng, { icon: icon });
            }

            function createLine(points, options) {
                const dashArray = options.lineStyle === 'dashed' ? '10, 10' : null;
                const weight = options.weight;
                const color = options.color;
                const opacity = options.opacity || 1;
                let pointsToDraw = points;
                if (options.lineType === 'bezier') {
                    pointsToDraw = getSplinePoints(points, 0.5, 32); 
                }
                const layer = L.polyline(pointsToDraw, {
                    color: color, weight: weight, dashArray: dashArray, opacity: opacity
                });
                return layer;
            }

            function createArrow(points, options) {
                const color = options.color;
                const weight = options.weight;
                const text = options.arrowText;
                const opacity = options.opacity || 1;
                const lineLayer = createLine(points, {
                    lineStyle: 'solid',
                    lineType: options.lineType, 
                    weight: weight, 
                    color: color,
                    opacity: opacity
                });
                const lastPoint = points[points.length - 1];
                const prevPoint = points[points.length - 2] || points[0];
                const angleRad = Math.atan2(lastPoint.lat - prevPoint.lat, lastPoint.lng - prevPoint.lng);
                const angleDeg = angleRad * (180 / Math.PI);
                const arrowSize = weight * 3;
                const arrowIcon = L.divIcon({
                    className: 'arrow-icon',
                    html: `<div style="color: ${color}; opacity: ${opacity}; font-size: ${arrowSize}px; transform: rotate(${-angleDeg - 90}deg); line-height: 1; display: flex; align-items: center; justify-content: center;">‚ñº</div><span style="position:absolute; bottom:100%; left:50%; transform:translate(-50%, -10px); color:${color}; opacity: ${opacity}; white-space:nowrap;">${text}</span>`,
                    iconSize: [arrowSize, arrowSize],
                    iconAnchor: [arrowSize / 2, arrowSize / 2]
                });
                const arrowMarker = L.marker(lastPoint, { icon: arrowIcon });
                const group = L.layerGroup([lineLayer, arrowMarker]);
                group.removeArrow = () => { map.removeLayer(lineLayer); map.removeLayer(arrowMarker); };
                return { layer: group, type: 'arrow', date: new Date(currentDate), options: options, points: points };
            }

            function createChevron(points, options, map) {
                const color = options.color;
                const weight = options.weight;
                const opacity = options.opacity || 1;
                let pathPoints = points;
                if (options.lineType === 'bezier') {
                    pathPoints = getSplinePoints(points, 0.5, 32);
                }
                let totalDistance = 0;
                const segments = [];
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const p1 = pathPoints[i];
                    const p2 = pathPoints[i + 1];
                    const dx = p2.lng - p1.lng;
                    const dy = p2.lat - p1.lat;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    segments.push({ p1, p2, distance: dist, angle: Math.atan2(dy, dx) });
                    totalDistance += dist;
                }
                
                // Ê†πÊçÆÁº©ÊîæÁ∫ßÂà´Âä®ÊÄÅË∞ÉÊï¥Èõ™‰ΩõÈæôÂ§ßÂ∞è
                // Âú®Leaflet‰∏≠Ôºå256ÂÉèÁ¥† = 360Â∫¶ / 2^zoom
                // ÊâÄ‰ª• 1ÂÉèÁ¥† = 360 / (256 * 2^zoom) Â∫¶
                const currentZoom = map.getZoom();
                const pixelSize = 360 / (256 * Math.pow(2, currentZoom)); // 1ÂÉèÁ¥†ÂØπÂ∫îÁöÑÂ∫¶Êï∞
                
                const desiredPixelWidth = 15; // ÊúüÊúõÁöÑÂÉèÁ¥†ÂÆΩÂ∫¶
                const desiredPixelHeight = weight * 1.5; // ÊúüÊúõÁöÑÂÉèÁ¥†È´òÂ∫¶
                
                const chevronWidth = desiredPixelWidth * pixelSize;
                const chevronHeight = desiredPixelHeight * pixelSize;
                const spacing = chevronWidth * 0.5; 
                const chevronCount = Math.floor(totalDistance / (chevronWidth + spacing)); 
                const chevrons = [];
                for (let i = 0; i < chevronCount; i++) {
                    const targetDist = (i + 0.5) * (totalDistance / chevronCount);
                    let accumulatedDist = 0;
                    let segment = null;
                    let localDist = 0;
                    for (const seg of segments) {
                        if (accumulatedDist + seg.distance >= targetDist) {
                            segment = seg;
                            localDist = targetDist - accumulatedDist;
                            break;
                        }
                        accumulatedDist += seg.distance;
                    }
                    if (!segment) continue;
                    const ratio = localDist / segment.distance;
                    const centerLat = segment.p1.lat + (segment.p2.lat - segment.p1.lat) * ratio;
                    const centerLng = segment.p1.lng + (segment.p2.lng - segment.p1.lng) * ratio;
                    const angle = segment.angle;
                    const hw = chevronWidth / 2;
                    const hh = chevronHeight / 2;
                    const points = [
                        L.latLng(
                            centerLat - hw * Math.sin(angle) - hh * Math.cos(angle),
                            centerLng - hw * Math.cos(angle) + hh * Math.sin(angle)
                        ),
                        L.latLng(
                            centerLat + hw * 0.40 * Math.sin(angle) - hh * 0.90 * Math.cos(angle),
                            centerLng + hw * 0.40 * Math.cos(angle) + hh * 0.90 * Math.sin(angle)
                        ),
                        L.latLng(
                            centerLat + hw * Math.sin(angle),
                            centerLng + hw * Math.cos(angle)
                        ),
                        L.latLng(
                            centerLat + hw * 0.40 * Math.sin(angle) + hh * 0.90 * Math.cos(angle),
                            centerLng + hw * 0.40 * Math.cos(angle) - hh * 0.90 * Math.sin(angle)
                        ),
                        L.latLng(
                            centerLat - hw * Math.sin(angle) + hh * Math.cos(angle),
                            centerLng - hw * Math.cos(angle) - hh * Math.sin(angle)
                        ),
                        L.latLng(
                            centerLat - hw * 0.40 * Math.sin(angle),
                            centerLng - hw * 0.40 * Math.cos(angle)
                        )
                    ];
                    chevrons.push(points);
                }
                const chevronLayers = chevrons.map(points => 
                    L.polygon(points, {
                        color: color,
                        fillColor: color,
                        fillOpacity: opacity,
                        weight: 0,
                        opacity: opacity
                    })
                );
                const group = L.layerGroup(chevronLayers);
                
                // Â≠òÂÇ®ÂàõÂª∫Êó∂ÁöÑÁº©ÊîæÁ∫ßÂà´
                group._chevronZoom = currentZoom;
                
                return { layer: group, type: 'chevron', date: new Date(currentDate), options: options, points: points };
            }

            function createTextBox(latlng, options) {
                const element = document.createElement('div');
                element.className = 'text-box';
                element.style.background = options.bgColor;
                element.style.opacity = options.opacity;
                element.style.borderColor = themeSettings.buttonColor;
                element.style.left = map.latLngToContainerPoint(latlng).x + 'px';
                element.style.top = map.latLngToContainerPoint(latlng).y + 'px';
                element.style.zIndex = 500 + annotations.textBoxes.length;
                const textarea = document.createElement('textarea');
                textarea.style.color = options.textColor;
                textarea.style.height = '100px'; 
                textarea.placeholder = 'Âú®Ê≠§ËæìÂÖ•ÊñáÊú¨...';
                element.appendChild(textarea);
                const closeBtn = document.createElement('span');
                closeBtn.className = 'text-box-close';
                closeBtn.innerHTML = '‚úï';
                element.appendChild(closeBtn);
                map.getContainer().appendChild(element);
                const draggable = new L.Draggable(element);
                draggable.enable();
                let currentLatLng = latlng;
                function updateLatLng() {
                    const newMapPoint = L.point(element.style.left.slice(0, -2), element.style.top.slice(0, -2));
                    currentLatLng = map.containerPointToLatLng(newMapPoint);
                }
                draggable.on('drag', updateLatLng);
                closeBtn.onclick = function() {
                    element.remove();
                    annotations.textBoxes = annotations.textBoxes.filter(t => t.element !== element);
                };
                function cleanup() {
                    map.removeEventListener('move', onMapMove);
                }
                function onMapMove() {
                    const newPoint = map.latLngToContainerPoint(currentLatLng);
                    element.style.left = newPoint.x + 'px';
                    element.style.top = newPoint.y + 'px';
                }
                map.on('move', onMapMove);
                return { 
                    element: element, 
                    type: 'textbox', 
                    date: new Date(currentDate), 
                    options: options, 
                    latlng: latlng,
                    content: textarea.value,
                    cleanup: cleanup
                };
            }

            map.on('click', function(e) {
                if (currentTool === 'annotate') {
                    if (drawingState.isDrawing) {
                        return; 
                    } 
                    const options = toolOptions.annotate;
                    if (options.markerType !== 'none') {
                        const markerLayer = createMarker(e.latlng, options);
                        annotations.markers.push({ 
                            layer: markerLayer, 
                            type: 'marker', 
                            date: new Date(currentDate), 
                            options: options, 
                            latlng: e.latlng,
                            zoomLevel: map.getZoom()
                        });
                        markerLayer.addTo(map);
                        updateLayersPanel();
                    }
                } else if (currentTool === 'text') {
                    const textBox = createTextBox(e.latlng, toolOptions.text);
                    textBox.zoomLevel = map.getZoom();
                    annotations.textBoxes.push(textBox);
                    updateLayersPanel();
                }
            });

            map.on('dblclick', function(e) {
                if (currentTool !== 'annotate') return;
                if (!drawingState.isDrawing) {
                    drawingState.isDrawing = true;
                    drawingState.points = [e.latlng];
                    drawingState.startPoint = e.latlng;
                    map.dragging.disable();
                } else {
                    drawingState.points.push(e.latlng);
                    if (drawingState.points.length >= 2) {
                        const lastPoint = drawingState.points[drawingState.points.length - 2];
                        const finalPoint = e.latlng;
                        const finalDashedSegment = L.polyline([lastPoint, finalPoint], {
                            color: toolOptions.annotate.color,
                            weight: toolOptions.annotate.weight,
                            opacity: 0.6,
                            dashArray: '10, 10'
                        }).addTo(map);
                        drawingState.dashedSegments.push(finalDashedSegment);
                    }
                    if (drawingState.points.length >= 2) {
                        const options = toolOptions.annotate;
                        let annotation;
                        if (drawingState.previewLayer) map.removeLayer(drawingState.previewLayer);
                        drawingState.dashedSegments.forEach(seg => map.removeLayer(seg));
                        if (options.lineStyle === 'arrow') {
                            annotation = createArrow(drawingState.points, options);
                            annotation.zoomLevel = map.getZoom();
                            annotations.arrows.push(annotation);
                            annotation.layer.addTo(map);
                        } else if (options.lineStyle === 'chevron') {
                            annotation = createChevron(drawingState.points, options, map);
                            annotation.zoomLevel = map.getZoom();
                            annotations.arrows.push(annotation);
                            annotation.layer.addTo(map);
                        } else {
                            const lineLayer = createLine(drawingState.points, options);
                            annotation = { 
                                layer: lineLayer, 
                                type: 'line', 
                                date: new Date(currentDate), 
                                options: options, 
                                points: drawingState.points,
                                zoomLevel: map.getZoom()
                            };
                            annotations.lines.push(annotation);
                            lineLayer.addTo(map);
                        }
                        
                        updateLayersPanel();
                    }
                    clearDrawingState();
                    map.dragging.disable();
                }
            });

            map.on('contextmenu', function(e) {
                if (currentTool === 'annotate' && drawingState.isDrawing) {
                    const lastPoint = drawingState.points[drawingState.points.length - 1];
                    const newPoint = e.latlng;
                    const dashedSegment = L.polyline([lastPoint, newPoint], {
                        color: toolOptions.annotate.color,
                        weight: toolOptions.annotate.weight,
                        opacity: 0.6,
                        dashArray: '10, 10'
                    }).addTo(map);
                    drawingState.dashedSegments.push(dashedSegment);
                    drawingState.points.push(newPoint);
                    map.fire('mousemove', { latlng: e.latlng });
                }
            });

            map.on('mousemove', function(e) {
                if (currentTool === 'eraser' && eraserState.isErasing) {
                } else if (drawingState.isDrawing && drawingState.points.length > 0) {
                    if (drawingState.previewLayer) map.removeLayer(drawingState.previewLayer);
                    const lastPoint = drawingState.points[drawingState.points.length - 1];
                    const options = toolOptions.annotate;
                    let previewPoints = [lastPoint, e.latlng];
                    if (options.lineType === 'bezier') {
                        const allPoints = [...drawingState.points, e.latlng];
                        previewPoints = getSplinePoints(allPoints, 0.5, 16); 
                    } else {
                        previewPoints = [lastPoint, e.latlng];
                    }
                    drawingState.previewLayer = L.polyline(previewPoints, {
                        color: options.color, weight: options.weight, opacity: 0.5, dashArray: '10, 10'
                    }).addTo(map);
                }
            });

            document.getElementById('save-btn').addEventListener('click', function() {
                const data = {
                    date: currentDate.toISOString().split('T')[0],
                    annotations: {
                        markers: annotations.markers.map(a => ({
                            type: a.type, date: a.date.toISOString(), options: a.options, latlng: a.latlng, zoomLevel: a.zoomLevel
                        })),
                        lines: annotations.lines.map(a => ({
                            type: a.type, date: a.date.toISOString(), options: a.options, points: a.points, zoomLevel: a.zoomLevel
                        })),
                        arrows: annotations.arrows.map(a => ({
                            type: a.type, date: a.date.toISOString(), options: a.options, points: a.points, zoomLevel: a.zoomLevel
                        })),
                        textBoxes: annotations.textBoxes.map(a => ({
                            type: a.type, date: a.date.toISOString(), options: a.options, latlng: a.latlng, content: a.element.querySelector('textarea').value, zoomLevel: a.zoomLevel
                        }))
                    },
                    boundaries: allBoundaries.map(b => ({
                        name: b.name,
                        type: b.type,
                        visible: b.visible,
                        geojson: b.layer.toGeoJSON()
                    })),
                    theme: themeSettings
                };
                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `map_data_${data.date}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert('Ê†áÊ≥®Êï∞ÊçÆÂ∑≤‰øùÂ≠ò!');
            });

            document.getElementById('load-btn').addEventListener('click', function() {
                document.getElementById('file-input').click();
            });

            document.getElementById('file-input').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const loadedData = JSON.parse(event.target.result);
                        [...annotations.markers, ...annotations.lines, ...annotations.arrows].forEach(a => {
                            if (a.layer) map.removeLayer(a.layer);
                        });
                        annotations.textBoxes.forEach(t => { 
                            if (t.cleanup) t.cleanup(); 
                            if (t.element) t.element.remove(); 
                        });
                        annotations.markers = [];
                        annotations.lines = [];
                        annotations.arrows = [];
                        annotations.textBoxes = [];
                        
                        allBoundaries.forEach(b => {
                            if (b.layer) boundaryLayers.removeLayer(b.layer);
                        });
                        allBoundaries = [];
                        
                        if (loadedData.theme) {
                            Object.assign(themeSettings, loadedData.theme);
                            document.getElementById('theme-button-color').value = themeSettings.buttonColor;
                            document.getElementById('theme-fill-color').value = themeSettings.fillColor;
                            document.getElementById('theme-fill-opacity').value = themeSettings.fillOpacity * 100;
                            document.getElementById('fill-opacity-value').textContent = Math.round(themeSettings.fillOpacity * 100) + '%';
                            applyTheme();
                        }
                        
                        if (loadedData.boundaries) {
                            loadedData.boundaries.forEach(b => {
                                const layer = L.geoJSON(b.geojson, {
                                    style: {
                                        color: '#ff0000',
                                        weight: 2,
                                        opacity: 0.8,
                                        fillColor: '#ff0000',
                                        fillOpacity: 0.1
                                    }
                                });
                                
                                const boundaryObj = {
                                    name: b.name,
                                    layer: layer,
                                    visible: b.visible !== false,
                                    type: b.type || 'unknown'
                                };
                                
                                allBoundaries.push(boundaryObj);
                                
                                const showCheckbox = document.getElementById('show-boundaries-checkbox');
                                if (showCheckbox && showCheckbox.checked && boundaryObj.visible) {
                                    boundaryLayers.addLayer(layer);
                                }
                            });
                        }
                        
                        const annotationsData = loadedData.annotations;
                        annotationsData.markers.forEach(a => {
                            const markerLayer = createMarker(a.latlng, a.options);
                            annotations.markers.push({ ...a, layer: markerLayer, date: new Date(a.date), zoomLevel: a.zoomLevel || 18 });
                        });
                        annotationsData.lines.forEach(a => {
                            const lineLayer = createLine(a.points, a.options);
                            annotations.lines.push({ ...a, layer: lineLayer, date: new Date(a.date), zoomLevel: a.zoomLevel || 18 });
                        });
                        annotationsData.arrows.forEach(a => {
                            let arrow;
                            if (a.type === 'chevron') {
                                arrow = createChevron(a.points, a.options, map);
                            } else {
                                arrow = createArrow(a.points, a.options);
                            }
                            arrow.zoomLevel = a.zoomLevel || 18;
                            annotations.arrows.push(arrow);
                        });
                        annotationsData.textBoxes.forEach(a => {
                            const box = createTextBox(a.latlng, a.options);
                            box.element.querySelector('textarea').value = a.content;
                            box.zoomLevel = a.zoomLevel || 18;
                            annotations.textBoxes.push(box);
                        });
                        if (loadedData.date) {
                            const [y, m, d] = loadedData.date.split('-').map(Number);
                            currentDate = new Date(y, m - 1, d);
                            updateDateDisplay();
                        } else {
                            updateVisibleAnnotations();
                        }
                        alert('Ê†áÊ≥®Êï∞ÊçÆÂ∑≤Âä†ËΩΩ!');
                    } catch (e) {
                        alert('Âä†ËΩΩÊñá‰ª∂Â§±Ë¥•,ËØ∑Á°Æ‰øùÊñá‰ª∂ÊòØÊúâÊïàÁöÑ JSON Ê†ºÂºè„ÄÇ');
                        console.error('File load error:', e);
                    }
                };
                reader.readAsText(file);
            });
            
            document.getElementById('settings-btn').addEventListener('click', () => {
                document.getElementById('settings-panel').classList.add('show');
            });

            document.querySelector('.close-settings').addEventListener('click', () => {
                document.getElementById('settings-panel').classList.remove('show');
            });

            document.getElementById('theme-button-color').addEventListener('change', (e) => {
                themeSettings.buttonColor = e.target.value;
                applyTheme();
            });

            document.getElementById('theme-fill-color').addEventListener('change', (e) => {
                themeSettings.fillColor = e.target.value;
                applyTheme();
            });

            document.getElementById('theme-fill-opacity').addEventListener('input', (e) => {
                themeSettings.fillOpacity = e.target.value / 100;
                document.getElementById('fill-opacity-value').textContent = e.target.value + '%';
                applyTheme();
            });

            const minZoom = 2;
            const maxZoom = 18;
            const zoomRange = maxZoom - minZoom;
            
            const zoomLevelsContainer = document.getElementById('zoom-levels');
            for (let i = minZoom; i <= maxZoom; i++) {
                const mark = document.createElement('div');
                mark.className = 'zoom-level-mark';
                mark.dataset.zoom = i;
                zoomLevelsContainer.appendChild(mark);
            }

            function updateZoomControl() {
                const currentZoom = map.getZoom();
                const roundedZoom = Math.round(currentZoom);
                const percentage = ((roundedZoom - minZoom) / zoomRange) * 100;
                const thumb = document.getElementById('zoom-slider-thumb');
                const track = document.getElementById('zoom-slider-track');
                thumb.style.bottom = percentage + '%';
                track.style.height = percentage + '%';
                document.querySelectorAll('.zoom-level-mark').forEach(mark => {
                    mark.classList.remove('current');
                    if (parseInt(mark.dataset.zoom) === roundedZoom) {
                        mark.classList.add('current');
                    }
                });
            }

            map.on('zoomend', updateZoomControl);
            map.on('zoomend', updateVisibleAnnotations);
            updateZoomControl();

            const thumb = document.getElementById('zoom-slider-thumb');
            const sliderContainer = document.getElementById('zoom-slider-container');
            let isDragging = false;
            
            thumb.addEventListener('mousedown', (e) => {
                isDragging = true;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const rect = sliderContainer.getBoundingClientRect();
                const y = e.clientY - rect.top;
                const percentage = Math.max(0, Math.min(100, ((rect.height - y) / rect.height) * 100));
                const zoom = minZoom + (percentage / 100) * zoomRange;
                map.setZoom(Math.round(zoom));
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            sliderContainer.addEventListener('click', (e) => {
                if (e.target === thumb) return;
                const rect = sliderContainer.getBoundingClientRect();
                const y = e.clientY - rect.top;
                const percentage = Math.max(0, Math.min(100, ((rect.height - y) / rect.height) * 100));
                const zoom = minZoom + (percentage / 100) * zoomRange;
                map.setZoom(Math.round(zoom));
            });

            applyTheme();
            initYearSelect();
            updateDateDisplay(); 
            updateMapCursor();
            initLocationSearch();
            initGeoJSONUpload();
            initTextToMarker();
            updateLayersPanel();
            document.querySelector('[data-tool="pan"]').style.background = `rgba(${hexToRgb(themeSettings.buttonColor)}, 0.5)`;
        });
    </script>
</body>
</html>